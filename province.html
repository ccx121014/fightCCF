<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fight CCF - 省选关卡</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        dark: '#1F2937',
                        light: '#F3F4F6',
                        danger: '#EF4444',
                        success: '#22C55E',
                        warning: '#F59E0B',
                        info: '#3B82F6'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                    animation: {
                        'glow': 'glow 2s ease-in-out infinite alternate',
                        'float': 'float 3s ease-in-out infinite',
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'shake': 'shake 0.5s cubic-bezier(.36,.07,.19,.97) both',
                        'slide-in': 'slideIn 0.5s ease-out',
                        'fade-in': 'fadeIn 0.5s ease-out',
                        'attack': 'attack 0.3s ease-out',
                        'hit': 'hit 0.3s ease-out',
                        'skill': 'skill 0.5s ease-out',
                        'victory': 'victory 1s ease-out',
                        'defeat': 'defeat 1s ease-out'
                    },
                    keyframes: {
                        glow: {
                            '0%': { boxShadow: '0 0 5px #fff, 0 0 10px #fff, 0 0 15px #0073e6, 0 0 20px #0073e6' },
                            '100%': { boxShadow: '0 0 10px #fff, 0 0 20px #fff, 0 0 30px #0073e6, 0 0 40px #0073e6' }
                        },
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' }
                        },
                        shake: {
                            '10%, 90%': { transform: 'translate3d(-1px, 0, 0)' },
                            '20%, 80%': { transform: 'translate3d(2px, 0, 0)' },
                            '30%, 50%, 70%': { transform: 'translate3d(-4px, 0, 0)' },
                            '40%, 60%': { transform: 'translate3d(4px, 0, 0)' }
                        },
                        slideIn: {
                            '0%': { transform: 'translateX(-100%)', opacity: '0' },
                            '100%': { transform: 'translateX(0)', opacity: '1' }
                        },
                        fadeIn: {
                            '0%': { opacity: '0' },
                            '100%': { opacity: '1' }
                        },
                        attack: {
                            '0%': { transform: 'translateX(0)' },
                            '50%': { transform: 'translateX(50px)' },
                            '100%': { transform: 'translateX(0)' }
                        },
                        hit: {
                            '0%': { transform: 'translateX(0)' },
                            '50%': { transform: 'translateX(-20px)', opacity: '0.7' },
                            '100%': { transform: 'translateX(0)', opacity: '1' }
                        },
                        skill: {
                            '0%': { transform: 'scale(1)', opacity: '0.5' },
                            '50%': { transform: 'scale(1.2)', opacity: '1' },
                            '100%': { transform: 'scale(1)', opacity: '1' }
                        },
                        victory: {
                            '0%': { transform: 'translateY(0)' },
                            '25%': { transform: 'translateY(-20px)' },
                            '50%': { transform: 'translateY(0)' },
                            '75%': { transform: 'translateY(-10px)' },
                            '100%': { transform: 'translateY(0)' }
                        },
                        defeat: {
                            '0%': { transform: 'rotate(0deg)' },
                            '25%': { transform: 'rotate(-5deg)' },
                            '50%': { transform: 'rotate(5deg)' },
                            '75%': { transform: 'rotate(-3deg)' },
                            '100%': { transform: 'rotate(0deg)' }
                        }
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .text-shadow {
                text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .text-shadow-lg {
                text-shadow: 0 4px 8px rgba(0,0,0,0.2);
            }
            .glass {
                background: rgba(255, 255, 255, 0.25);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.18);
            }
            .health-bar {
                transition: width 0.3s ease;
            }
            .energy-bar {
                transition: width 0.3s ease;
            }
            .cooldown-overlay {
                background: rgba(0, 0, 0, 0.7);
                transition: opacity 0.3s ease;
            }
            .fighter {
                transition: all 0.3s ease;
            }
            .projectile {
                position: absolute;
                width: 20px;
                height: 20px;
                background: #F97316;
                border-radius: 50%;
                animation: projectileMove 0.5s linear;
            }
            @keyframes projectileMove {
                from {
                    transform: translateX(0);
                }
                to {
                    transform: translateX(300px);
                }
            }
            .explosion {
                position: absolute;
                width: 50px;
                height: 50px;
                background: radial-gradient(circle, #F97316 0%, #EA580C 100%);
                border-radius: 50%;
                animation: explosion 0.5s ease-out forwards;
            }
            @keyframes explosion {
                0% {
                    transform: scale(0);
                    opacity: 1;
                }
                100% {
                    transform: scale(2);
                    opacity: 0;
                }
            }
            .ds-structure {
                position: absolute;
                background: rgba(249, 115, 22, 0.3);
                border: 2px solid #F97316;
                animation: dsExpand 0.8s ease-out;
            }
            @keyframes dsExpand {
                0% {
                    transform: scale(0);
                    opacity: 0;
                }
                100% {
                    transform: scale(1);
                    opacity: 1;
                }
            }
            .hash-node {
                position: absolute;
                width: 40px;
                height: 40px;
                background: linear-gradient(135deg, #F97316 0%, #EA580C 100%);
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-weight: bold;
                animation: hashAppear 0.5s ease-out;
            }
            @keyframes hashAppear {
                0% {
                    transform: scale(0) rotate(180deg);
                    opacity: 0;
                }
                100% {
                    transform: scale(1) rotate(0deg);
                    opacity: 1;
                }
            }
        }
    </style>
    <style>
        body {
            background: linear-gradient(135deg, #78350f 0%, #9a3412 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .battlefield {
            position: relative;
            height: 400px;
            background: linear-gradient(to bottom, #1c1917 0%, #18181b 100%);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .battlefield::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="0.5"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>');
            opacity: 0.3;
        }
        
        .fighter {
            position: absolute;
            bottom: 50px;
            width: 80px;
            height: 120px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2rem;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }
        
        .player {
            left: 100px;
            background: linear-gradient(135deg, #F97316 0%, #EA580C 100%);
        }
        
        .enemy {
            right: 100px;
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
        }
        
        .ui-panel {
            background: rgba(31, 41, 55, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 1rem;
        }
        
        .skill-button {
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .skill-button:hover:not(.disabled) {
            transform: translateY(-3px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }
        
        .skill-button.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .countdown {
            font-variant-numeric: tabular-nums;
        }
        
        .floating-text {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
        }
        
        @keyframes floatUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px);
                opacity: 0;
            }
        }
        
        .battle-log {
            max-height: 200px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #F97316 #1F2937;
        }
        
        .battle-log::-webkit-scrollbar {
            width: 6px;
        }
        
        .battle-log::-webkit-scrollbar-track {
            background: #1F2937;
        }
        
        .battle-log::-webkit-scrollbar-thumb {
            background: #F97316;
            border-radius: 3px;
        }
        
        .algorithm-node {
            position: absolute;
            width: 40px;
            height: 40px;
            background: #F97316;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            animation: float 3s ease-in-out infinite;
        }
        
        .connection-line {
            position: absolute;
            height: 2px;
            background: rgba(249, 115, 22, 0.5);
            transform-origin: left center;
        }
        
        /* 禁用右键和Ctrl键 */
        body {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body class="font-sans text-gray-100">
    <!-- 顶部导航 -->
    <header class="glass sticky top-0 z-50 px-6 py-4 flex justify-between items-center">
        <div class="flex items-center space-x-2">
            <button id="back-btn" class="bg-dark/50 hover:bg-dark/80 text-white p-2 rounded-lg transition">
                <i class="fa fa-arrow-left"></i>
            </button>
            <h1 class="text-2xl font-bold text-shadow">Fight CCF - 省选</h1>
        </div>
        <div class="flex items-center space-x-4">
            <div class="bg-dark/50 px-4 py-2 rounded-lg">
                <span class="text-sm text-gray-400">关卡:</span>
                <span id="current-chapter" class="ml-2 font-semibold">4-1</span>
            </div>
            <div class="bg-dark/50 px-4 py-2 rounded-lg">
                <span class="text-sm text-gray-400">时间:</span>
                <span id="countdown" class="ml-2 font-semibold countdown">120</span>
            </div>
        </div>
    </header>
    
    <!-- 主要内容 -->
    <main class="container mx-auto px-4 py-8">
        <!-- 战场区域 -->
        <div class="battlefield mb-6">
            <!-- 算法节点和连接线 -->
            <div id="algorithm-network" class="absolute inset-0 pointer-events-none"></div>
            
            <!-- 玩家 -->
            <div id="player" class="fighter player">
                <i class="fa fa-database"></i>
            </div>
            
            <!-- 敌人 -->
            <div id="enemy" class="fighter enemy">
                <i class="fa fa-code"></i>
            </div>
            
            <!-- 战斗效果将通过JS动态添加 -->
        </div>
        
        <!-- 状态面板 -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
            <!-- 玩家状态 -->
            <div class="ui-panel">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="font-bold text-lg">数据结构师</h3>
                    <div class="flex items-center space-x-2">
                        <span class="text-yellow-400">
                            <i class="fa fa-bolt"></i>
                            <span id="player-energy">100</span>
                        </span>
                    </div>
                </div>
                
                <!-- 生命值 -->
                <div class="mb-4">
                    <div class="flex justify-between text-sm mb-1">
                        <span>生命值</span>
                        <span id="player-health-text">160/160</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-3">
                        <div id="player-health-bar" class="health-bar bg-green-500 h-3 rounded-full" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- 能量值 -->
                <div>
                    <div class="flex justify-between text-sm mb-1">
                        <span>能量值</span>
                        <span id="player-energy-text">100/100</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-3">
                        <div id="player-energy-bar" class="energy-bar bg-yellow-400 h-3 rounded-full" style="width: 100%"></div>
                    </div>
                </div>
            </div>
            
            <!-- 敌人状态 -->
            <div class="ui-panel">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="font-bold text-lg" id="enemy-name">算法怪</h3>
                    <div class="flex items-center space-x-1">
                        <span class="text-cyan-500">Lv.</span>
                        <span id="enemy-level">7</span>
                    </div>
                </div>
                
                <!-- 生命值 -->
                <div class="mb-4">
                    <div class="flex justify-between text-sm mb-1">
                        <span>生命值</span>
                        <span id="enemy-health-text">280/280</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-3">
                        <div id="enemy-health-bar" class="health-bar bg-cyan-500 h-3 rounded-full" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- 算法弱点 -->
                <div>
                    <div class="text-sm mb-1">算法弱点</div>
                    <div class="flex flex-wrap gap-2">
                        <span class="bg-orange-500/20 text-orange-300 text-xs px-2 py-1 rounded-full">二叉搜索</span>
                        <span class="bg-red-500/20 text-red-300 text-xs px-2 py-1 rounded-full">哈希碰撞</span>
                    </div>
                </div>
            </div>
            
            <!-- 战斗日志 -->
            <div class="ui-panel">
                <h3 class="font-bold text-lg mb-4">战斗日志</h3>
                <div id="battle-log" class="battle-log text-sm space-y-2">
                    <div class="text-gray-400">战斗开始！</div>
                </div>
            </div>
        </div>
        
        <!-- 技能面板 -->
        <div class="ui-panel">
            <h3 class="font-bold text-lg mb-4">技能</h3>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                <!-- 普攻 -->
                <div class="skill-button bg-gray-800 rounded-lg p-4 text-center" data-skill="normal">
                    <div class="w-12 h-12 mx-auto bg-gray-700 rounded-full mb-2 flex items-center justify-center">
                        <span class="text-xl font-bold">I</span>
                    </div>
                    <p class="font-medium">栈的压入</p>
                    <p class="text-xs text-gray-400">基础攻击</p>
                </div>
                
                <!-- 一技能 -->
                <div class="skill-button bg-gray-800 rounded-lg p-4 text-center" data-skill="skill1">
                    <div class="w-12 h-12 mx-auto bg-blue-500/20 rounded-full mb-2 flex items-center justify-center">
                        <span class="text-xl font-bold">J</span>
                    </div>
                    <p class="font-medium">队列操作</p>
                    <p class="text-xs text-gray-400">35点伤害</p>
                </div>
                
                <!-- 二技能 -->
                <div class="skill-button bg-gray-800 rounded-lg p-4 text-center" data-skill="skill2">
                    <div class="w-12 h-12 mx-auto bg-green-500/20 rounded-full mb-2 flex items-center justify-center">
                        <span class="text-xl font-bold">K</span>
                    </div>
                    <p class="font-medium">二叉搜索</p>
                    <p class="text-xs text-gray-400">45点伤害</p>
                </div>
                
                <!-- 三技能 -->
                <div class="skill-button bg-gray-800 rounded-lg p-4 text-center" data-skill="skill3">
                    <div class="w-12 h-12 mx-auto bg-red-500/20 rounded-full mb-2 flex items-center justify-center">
                        <span class="text-xl font-bold">L</span>
                    </div>
                    <p class="font-medium">哈希碰撞</p>
                    <p class="text-xs text-gray-400">70点伤害</p>
                </div>
            </div>
        </div>
        
        <!-- 按键说明 -->
        <div class="mt-6 bg-dark/50 rounded-lg p-4">
            <h4 class="font-bold mb-2">按键说明</h4>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                <div class="flex items-center space-x-2">
                    <span class="bg-gray-700 px-2 py-1 rounded">W</span>
                    <span>向上移动</span>
                </div>
                <div class="flex items-center space-x-2">
                    <span class="bg-gray-700 px-2 py-1 rounded">S</span>
                    <span>向下移动</span>
                </div>
                <div class="flex items-center space-x-2">
                    <span class="bg-gray-700 px-2 py-1 rounded">A</span>
                    <span>向左移动</span>
                </div>
                <div class="flex items-center space-x-2">
                    <span class="bg-gray-700 px-2 py-1 rounded">D</span>
                    <span>向右移动</span>
                </div>
                <div class="flex items-center space-x-2">
                    <span class="bg-primary px-2 py-1 rounded">I</span>
                    <span>普攻</span>
                </div>
                <div class="flex items-center space-x-2">
                    <span class="bg-blue-500 px-2 py-1 rounded">J</span>
                    <span>一技能</span>
                </div>
                <div class="flex items-center space-x-2">
                    <span class="bg-green-500 px-2 py-1 rounded">K</span>
                    <span>二技能</span>
                </div>
                <div class="flex items-center space-x-2">
                    <span class="bg-red-500 px-2 py-1 rounded">L</span>
                    <span>三技能</span>
                </div>
            </div>
        </div>
    </main>
    
    <!-- 胜利/失败模态框 -->
    <div id="result-modal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50 hidden">
        <div class="bg-dark text-white rounded-lg p-8 max-w-md w-full text-center animate-fade-in">
            <div id="result-icon" class="text-6xl mb-4"></div>
            <h2 id="result-title" class="text-2xl font-bold mb-2"></h2>
            <p id="result-message" class="mb-6"></p>
            <div class="flex flex-col space-y-3">
                <button id="next-btn" class="bg-primary hover:bg-blue-600 text-white py-3 rounded-lg transition">
                    下一关
                </button>
                <button id="restart-btn" class="bg-gray-700 hover:bg-gray-600 text-white py-3 rounded-lg transition">
                    重新挑战
                </button>
                <button id="home-btn" class="bg-gray-800 hover:bg-gray-700 text-white py-3 rounded-lg transition">
                    返回主页
                </button>
            </div>
        </div>
    </div>
    
    <script>
        // 游戏数据
        const gameState = {
            player: {
                health: 160,
                maxHealth: 160,
                energy: 100,
                maxEnergy: 100,
                position: { x: 100, y: 50 },
                skills: {
                    normal: { name: '栈的压入', damage: 18, energy: 0, cooldown: 0 },
                    skill1: { name: '队列操作', damage: 35, energy: 35, cooldown: 3 },
                    skill2: { name: '二叉搜索', damage: 45, energy: 45, cooldown: 5 },
                    skill3: { name: '哈希碰撞', damage: 70, energy: 70, cooldown: 8 }
                },
                currentCooldowns: {}
            },
            enemy: {
                health: 280,
                maxHealth: 280,
                position: { x: 0, y: 50 },
                damage: 30,
                attackInterval: 1400,
                lastAttack: 0
            },
            countdown: 120,
            isGameOver: false,
            isPlayerTurn: true,
            algorithmNodes: [],
            currentChapter: 4,
            currentLevel: 1
        };
        
        // DOM元素
        const player = document.getElementById('player');
        const enemy = document.getElementById('enemy');
        const playerHealthBar = document.getElementById('player-health-bar');
        const playerHealthText = document.getElementById('player-health-text');
        const playerEnergyBar = document.getElementById('player-energy-bar');
        const playerEnergyText = document.getElementById('player-energy-text');
        const enemyHealthBar = document.getElementById('enemy-health-bar');
        const enemyHealthText = document.getElementById('enemy-health-text');
        const enemyName = document.getElementById('enemy-name');
        const enemyLevel = document.getElementById('enemy-level');
        const countdownElement = document.getElementById('countdown');
        const battleLog = document.getElementById('battle-log');
        const algorithmNetwork = document.getElementById('algorithm-network');
        const resultModal = document.getElementById('result-modal');
        const resultIcon = document.getElementById('result-icon');
        const resultTitle = document.getElementById('result-title');
        const resultMessage = document.getElementById('result-message');
        const nextBtn = document.getElementById('next-btn');
        const restartBtn = document.getElementById('restart-btn');
        const homeBtn = document.getElementById('home-btn');
        const backBtn = document.getElementById('back-btn');
        const currentChapterElement = document.getElementById('current-chapter');
        
        // 初始化
        document.addEventListener('DOMContentLoaded', () => {
            initializeGame();
            startGameLoop();
            generateAlgorithmNetwork();
            
            // 禁用右键和Ctrl键
            disableRightClickAndCtrl();
        });
        
        // 初始化游戏
        function initializeGame() {
            // 设置敌人位置
            const battlefieldRect = document.querySelector('.battlefield').getBoundingClientRect();
            gameState.enemy.position.x = battlefieldRect.width - 180;
            
            // 更新UI
            updatePlayerUI();
            updateEnemyUI();
            currentChapterElement.textContent = `${gameState.currentChapter}-${gameState.currentLevel}`;
            
            // 设置敌人信息
            const enemies = [
                { name: '算法怪', level: 7, health: 280, damage: 30 },
                { name: '复杂度怪', level: 8, health: 320, damage: 35 },
                { name: '优化怪', level: 9, health: 360, damage: 40 },
                { name: '系统怪', level: 10, health: 400, damage: 45 }
            ];
            
            const currentEnemy = enemies[gameState.currentLevel - 1] || enemies[0];
            enemyName.textContent = currentEnemy.name;
            enemyLevel.textContent = currentEnemy.level;
            gameState.enemy.health = currentEnemy.health;
            gameState.enemy.maxHealth = currentEnemy.health;
            gameState.enemy.damage = currentEnemy.damage;
            
            // 添加战斗日志
            addBattleLog(`战斗开始！你遇到了 ${currentEnemy.name} Lv.${currentEnemy.level}`);
        }
        
        // 开始游戏循环
        function startGameLoop() {
            const gameLoop = setInterval(() => {
                if (gameState.isGameOver) {
                    clearInterval(gameLoop);
                    return;
                }
                
                // 更新倒计时
                gameState.countdown--;
                countdownElement.textContent = gameState.countdown;
                
                if (gameState.countdown <= 0) {
                    endGame(false);
                }
                
                // 敌人AI
                if (!gameState.isPlayerTurn) {
                    const now = Date.now();
                    if (now - gameState.enemy.lastAttack > gameState.enemy.attackInterval) {
                        enemyAttack();
                        gameState.enemy.lastAttack = now;
                    }
                }
                
                // 更新技能冷却
                updateCooldowns();
                
                // 恢复能量
                if (gameState.player.energy < gameState.player.maxEnergy) {
                    gameState.player.energy = Math.min(gameState.player.maxEnergy, gameState.player.energy + 1);
                    updatePlayerUI();
                }
            }, 1000);
        }
        
        // 生成算法网络
        function generateAlgorithmNetwork() {
            algorithmNetwork.innerHTML = '';
            
            const battlefieldRect = document.querySelector('.battlefield').getBoundingClientRect();
            
            // 生成数据结构节点
            generateDataStructures(battlefieldRect);
        }
        
        // 生成数据结构
        function generateDataStructures(battlefieldRect) {
            // 生成栈结构
            const stackX = 150;
            const stackY = 100;
            const stackHeight = 120;
            const stackWidth = 40;
            
            const stack = document.createElement('div');
            stack.className = 'ds-structure';
            stack.style.left = `${stackX}px`;
            stack.style.top = `${stackY}px`;
            stack.style.width = `${stackWidth}px`;
            stack.style.height = `${stackHeight}px`;
            stack.style.borderRadius = '5px';
            algorithmNetwork.appendChild(stack);
            
            // 生成栈元素
            for (let i = 0; i < 3; i++) {
                const stackElement = document.createElement('div');
                stackElement.className = 'algorithm-node';
                stackElement.textContent = i + 1;
                stackElement.style.left = `${stackX + 20}px`;
                stackElement.style.top = `${stackY + stackHeight - 30 - i * 30}px`;
                algorithmNetwork.appendChild(stackElement);
                
                gameState.algorithmNodes.push({
                    element: stackElement,
                    position: { x: stackX + 20, y: stackY + stackHeight - 30 - i * 30 },
                    type: 'stack'
                });
            }
            
            // 生成队列结构
            const queueX = 300;
            const queueY = 150;
            const queueWidth = 120;
            const queueHeight = 40;
            
            const queue = document.createElement('div');
            queue.className = 'ds-structure';
            queue.style.left = `${queueX}px`;
            queue.style.top = `${queueY}px`;
            queue.style.width = `${queueWidth}px`;
            queue.style.height = `${queueHeight}px`;
            queue.style.borderRadius = '5px';
            algorithmNetwork.appendChild(queue);
            
            // 生成队列元素
            for (let i = 0; i < 3; i++) {
                const queueElement = document.createElement('div');
                queueElement.className = 'algorithm-node';
                queueElement.textContent = i + 4;
                queueElement.style.left = `${queueX + 20 + i * 30}px`;
                queueElement.style.top = `${queueY + 20}px`;
                algorithmNetwork.appendChild(queueElement);
                
                gameState.algorithmNodes.push({
                    element: queueElement,
                    position: { x: queueX + 20 + i * 30, y: queueY + 20 },
                    type: 'queue'
                });
            }
            
            // 生成二叉树结构
            const treeX = 500;
            const treeY = 100;
            const treeLevelHeight = 60;
            
            // 根节点
            const rootNode = document.createElement('div');
            rootNode.className = 'algorithm-node';
            rootNode.textContent = 'R';
            rootNode.style.left = `${treeX}px`;
            rootNode.style.top = `${treeY}px`;
            algorithmNetwork.appendChild(rootNode);
            
            gameState.algorithmNodes.push({
                element: rootNode,
                position: { x: treeX, y: treeY },
                type: 'tree'
            });
            
            // 左子节点
            const leftNode = document.createElement('div');
            leftNode.className = 'algorithm-node';
            leftNode.textContent = 'L';
            leftNode.style.left = `${treeX - 50}px`;
            leftNode.style.top = `${treeY + treeLevelHeight}px`;
            algorithmNetwork.appendChild(leftNode);
            
            gameState.algorithmNodes.push({
                element: leftNode,
                position: { x: treeX - 50, y: treeY + treeLevelHeight },
                type: 'tree'
            });
            
            // 右子节点
            const rightNode = document.createElement('div');
            rightNode.className = 'algorithm-node';
            rightNode.textContent = 'R';
            rightNode.style.left = `${treeX + 50}px`;
            rightNode.style.top = `${treeY + treeLevelHeight}px`;
            algorithmNetwork.appendChild(rightNode);
            
            gameState.algorithmNodes.push({
                element: rightNode,
                position: { x: treeX + 50, y: treeY + treeLevelHeight },
                type: 'tree'
            });
            
            // 添加连接线
            addConnections();
        }
        
        // 添加连接线
        function addConnections() {
            const battlefield = document.querySelector('.battlefield');
            
            // 连接栈元素
            const stackNodes = gameState.algorithmNodes.filter(node => node.type === 'stack');
            for (let i = 0; i < stackNodes.length - 1; i++) {
                const line = createConnectionLine(stackNodes[i].position, stackNodes[i + 1].position);
                battlefield.appendChild(line);
            }
            
            // 连接队列元素
            const queueNodes = gameState.algorithmNodes.filter(node => node.type === 'queue');
            for (let i = 0; i < queueNodes.length - 1; i++) {
                const line = createConnectionLine(queueNodes[i].position, queueNodes[i + 1].position);
                battlefield.appendChild(line);
            }
            
            // 连接二叉树元素
            const treeNodes = gameState.algorithmNodes.filter(node => node.type === 'tree');
            if (treeNodes.length >= 3) {
                const root = treeNodes[0];
                const left = treeNodes[1];
                const right = treeNodes[2];
                
                const leftLine = createConnectionLine(root.position, left.position);
                const rightLine = createConnectionLine(root.position, right.position);
                
                battlefield.appendChild(leftLine);
                battlefield.appendChild(rightLine);
            }
        }
        
        // 创建连接线
        function createConnectionLine(start, end) {
            const line = document.createElement('div');
            line.className = 'connection-line';
            
            const length = Math.sqrt(
                Math.pow(end.x - start.x, 2) +
                Math.pow(end.y - start.y, 2)
            );
            
            const angle = Math.atan2(
                end.y - start.y,
                end.x - start.x
            ) * 180 / Math.PI;
            
            line.style.width = `${length}px`;
            line.style.left = `${start.x + 20}px`;
            line.style.top = `${start.y + 20}px`;
            line.style.transform = `rotate(${angle}deg)`;
            
            return line;
        }
        
        // 玩家移动
        function movePlayer(direction) {
            const battlefieldRect = document.querySelector('.battlefield').getBoundingClientRect();
            const speed = 20;
            
            switch (direction) {
                case 'up':
                    gameState.player.position.y = Math.max(50, gameState.player.position.y - speed);
                    break;
                case 'down':
                    gameState.player.position.y = Math.min(battlefieldRect.height - 170, gameState.player.position.y + speed);
                    break;
                case 'left':
                    gameState.player.position.x = Math.max(50, gameState.player.position.x - speed);
                    break;
                case 'right':
                    gameState.player.position.x = Math.min(battlefieldRect.width / 2 - 90, gameState.player.position.x + speed);
                    break;
            }
            
            updatePlayerPosition();
        }
        
        // 更新玩家位置
        function updatePlayerPosition() {
            player.style.left = `${gameState.player.position.x}px`;
            player.style.bottom = `${gameState.player.position.y}px`;
        }
        
        // 玩家攻击
        function playerAttack(skillType) {
            if (gameState.isGameOver || !gameState.isPlayerTurn) return;
            
            const skill = gameState.player.skills[skillType];
            
            // 检查能量和冷却
            if (gameState.player.energy < skill.energy) {
                addBattleLog('能量不足！', 'warning');
                return;
            }
            
            if (gameState.player.currentCooldowns[skillType] > 0) {
                addBattleLog(`${skill.name} 冷却中 (${gameState.player.currentCooldowns[skillType]}s)`, 'warning');
                return;
            }
            
            // 消耗能量
            gameState.player.energy -= skill.energy;
            
            // 设置冷却
            gameState.player.currentCooldowns[skillType] = skill.cooldown;
            
            // 播放攻击动画
            playAttackAnimation(skillType);
            
            // 计算伤害
            let damage = skill.damage;
            
            // 弱点加成
            if (skillType === 'skill2' || skillType === 'skill3') {
                damage = Math.floor(damage * 1.5);
                addBattleLog(`弱点攻击！${skill.name} 造成 ${damage} 点伤害`, 'critical');
            } else {
                addBattleLog(`${skill.name} 造成 ${damage} 点伤害`);
            }
            
            // 扣除敌人生命值
            gameState.enemy.health = Math.max(0, gameState.enemy.health - damage);
            
            // 更新UI
            updatePlayerUI();
            updateEnemyUI();
            
            // 检查敌人是否死亡
            if (gameState.enemy.health <= 0) {
                endGame(true);
                return;
            }
            
            // 切换回合
            gameState.isPlayerTurn = false;
        }
        
        // 播放攻击动画
        function playAttackAnimation(skillType) {
            // 玩家攻击动画
            player.classList.add('animate-attack');
            setTimeout(() => {
                player.classList.remove('animate-attack');
            }, 300);
            
            // 敌人受击动画
            setTimeout(() => {
                enemy.classList.add('animate-hit');
                setTimeout(() => {
                    enemy.classList.remove('animate-hit');
                }, 300);
                
                // 创建伤害数字
                createDamageNumber(gameState.enemy.health, enemy);
                
                // 根据技能类型创建不同的特效
                if (skillType === 'skill1') {
                    createQueueEffect();
                } else if (skillType === 'skill2') {
                    createBinarySearchEffect();
                } else if (skillType === 'skill3') {
                    createHashCollisionEffect();
                } else {
                    createExplosion(enemy);
                }
            }, 150);
        }
        
        // 创建队列效果
        function createQueueEffect() {
            const battlefield = document.querySelector('.battlefield');
            const playerRect = player.getBoundingClientRect();
            const enemyRect = enemy.getBoundingClientRect();
            const battlefieldRect = battlefield.getBoundingClientRect();
            
            // 创建队列元素
            const queueElements = [];
            const queueSize = 4;
            
            for (let i = 0; i < queueSize; i++) {
                const element = document.createElement('div');
                element.className = 'hash-node';
                element.textContent = i + 1;
                element.style.left = `${playerRect.left - battlefieldRect.left + 40}px`;
                element.style.top = `${playerRect.top - battlefieldRect.top + 60}px`;
                element.style.opacity = '0';
                
                battlefield.appendChild(element);
                queueElements.push(element);
            }
            
            // 队列操作动画
            queueElements.forEach((element, index) => {
                setTimeout(() => {
                    // 入队
                    element.style.transition = 'all 0.3s ease';
                    element.style.opacity = '1';
                    element.style.left = `${playerRect.left - battlefieldRect.left + 80 + index * 40}px`;
                    
                    // 出队并攻击敌人
                    setTimeout(() => {
                        element.style.transition = 'all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                        element.style.left = `${enemyRect.left - battlefieldRect.left + 40}px`;
                        element.style.top = `${enemyRect.top - battlefieldRect.top + 60}px`;
                        
                        // 攻击后消失
                        setTimeout(() => {
                            element.style.opacity = '0';
                            setTimeout(() => {
                                element.remove();
                                
                                // 最后一个元素触发爆炸
                                if (index === queueElements.length - 1) {
                                    createExplosion(enemy);
                                }
                            }, 300);
                        }, 500);
                    }, 300);
                }, index * 200);
            });
        }
        
        // 创建二叉搜索效果
        function createBinarySearchEffect() {
            const battlefield = document.querySelector('.battlefield');
            const enemyRect = enemy.getBoundingClientRect();
            const battlefieldRect = battlefield.getBoundingClientRect();
            
            // 找到树节点
            const treeNodes = gameState.algorithmNodes.filter(node => node.type === 'tree');
            if (treeNodes.length === 0) {
                createExplosion(enemy);
                return;
            }
            
            // 模拟二叉搜索过程
            const searchPath = [];
            const targetValue = 7; // 目标值
            
            // 简单的搜索路径模拟
            if (treeNodes.length >= 3) {
                searchPath.push(treeNodes[0]); // 根节点
                searchPath.push(targetValue > 5 ? treeNodes[2] : treeNodes[1]); // 左右子节点
            }
            
            // 按路径激活节点
            searchPath.forEach((node, index) => {
                setTimeout(() => {
                    // 节点高亮
                    node.element.style.boxShadow = '0 0 20px rgba(249, 115, 22, 0.8)';
                    node.element.style.transform = 'scale(1.3)';
                    node.element.style.zIndex = '20';
                    
                    // 连接线
                    if (index > 0) {
                        const prevNode = searchPath[index - 1];
                        const edge = createConnectionLine(prevNode.position, node.position);
                        edge.style.height = '4px';
                        edge.style.background = 'linear-gradient(90deg, rgba(249, 115, 22, 0.8), rgba(234, 88, 12, 0.4))';
                        battlefield.appendChild(edge);
                        
                        setTimeout(() => {
                            edge.remove();
                        }, 800);
                    }
                    
                    setTimeout(() => {
                        node.element.style.boxShadow = '';
                        node.element.style.transform = '';
                        node.element.style.zIndex = '';
                        
                        // 最后一个节点触发攻击
                        if (index === searchPath.length - 1) {
                            // 从最后一个节点发射攻击到敌人
                            const attack = document.createElement('div');
                            attack.style.position = 'absolute';
                            attack.style.width = '6px';
                            attack.style.height = '6px';
                            attack.style.background = '#F97316';
                            attack.style.borderRadius = '50%';
                            attack.style.boxShadow = '0 0 10px rgba(249, 115, 22, 0.8)';
                            
                            attack.style.left = `${node.position.x + 20}px`;
                            attack.style.top = `${node.position.y + 20}px`;
                            
                            battlefield.appendChild(attack);
                            
                            // 计算到敌人的距离和角度
                            const targetX = enemyRect.left - battlefieldRect.left + 40;
                            const targetY = enemyRect.top - battlefieldRect.top + 60;
                            
                            const distanceX = targetX - (node.position.x + 20);
                            const distanceY = targetY - (node.position.y + 20);
                            
                            // 设置动画
                            attack.style.transition = `all 0.8s linear`;
                            
                            setTimeout(() => {
                                attack.style.left = `${targetX}px`;
                                attack.style.top = `${targetY}px`;
                                
                                setTimeout(() => {
                                    attack.remove();
                                    createExplosion(enemy);
                                }, 800);
                            }, 10);
                        }
                    }, 600);
                }, index * 800);
            });
        }
        
        // 创建哈希碰撞效果
        function createHashCollisionEffect() {
            const battlefield = document.querySelector('.battlefield');
            const enemyRect = enemy.getBoundingClientRect();
            const battlefieldRect = battlefield.getBoundingClientRect();
            
            // 创建哈希表
            const hashTable = [];
            const tableSize = 5;
            
            for (let i = 0; i < tableSize; i++) {
                const bucket = document.createElement('div');
                bucket.className = 'hash-node';
                bucket.textContent = '';
                bucket.style.width = '50px';
                bucket.style.height = '50px';
                bucket.style.left = `${100 + i * 80}px`;
                bucket.style.top = `${150}px`;
                bucket.style.opacity = '0.7';
                
                battlefield.appendChild(bucket);
                hashTable.push(bucket);
            }
            
            // 插入元素导致碰撞
            const elements = [
                { key: 'A', value: 1, hash: 1 },
                { key: 'B', value: 2, hash: 2 },
                { key: 'C', value: 3, hash: 1 }, // 碰撞
                { key: 'D', value: 4, hash: 3 },
                { key: 'E', value: 5, hash: 2 }  // 碰撞
            ];
            
            elements.forEach((element, index) => {
                setTimeout(() => {
                    const bucketIndex = element.hash % tableSize;
                    const bucket = hashTable[bucketIndex];
                    
                    // 显示元素
                    const hashElement = document.createElement('div');
                    hashElement.className = 'hash-node';
                    hashElement.textContent = element.key;
                    hashElement.style.left = `${bucket.offsetLeft + 25}px`;
                    hashElement.style.top = `${bucket.offsetTop - 30 - (bucket.textContent ? 30 : 0)}px`;
                    
                    battlefield.appendChild(hashElement);
                    
                    // 如果发生碰撞，创建链接
                    if (bucket.textContent) {
                        const collisionLine = document.createElement('div');
                        collisionLine.className = 'connection-line';
                        collisionLine.style.height = '3px';
                        collisionLine.style.background = '#EF4444';
                        collisionLine.style.width = '30px';
                        collisionLine.style.left = `${bucket.offsetLeft + 25}px`;
                        collisionLine.style.top = `${bucket.offsetTop - 15}px`;
                        collisionLine.style.transform = 'rotate(90deg)';
                        
                        battlefield.appendChild(collisionLine);
                        
                        // 碰撞特效
                        bucket.style.boxShadow = '0 0 20px rgba(239, 68, 68, 0.8)';
                        hashElement.style.boxShadow = '0 0 20px rgba(239, 68, 68, 0.8)';
                        
                        // 最后一次碰撞触发大爆炸
                        if (index === elements.length - 1) {
                            setTimeout(() => {
                                // 从所有碰撞的桶发射攻击
                                hashTable.forEach((bucket, bucketIndex) => {
                                    if (bucket.textContent) {
                                        setTimeout(() => {
                                            const attack = document.createElement('div');
                                            attack.style.position = 'absolute';
                                            attack.style.width = '8px';
                                            attack.style.height = '8px';
                                            attack.style.background = '#EF4444';
                                            attack.style.borderRadius = '50%';
                                            attack.style.boxShadow = '0 0 15px rgba(239, 68, 68, 0.8)';
                                            
                                            attack.style.left = `${bucket.offsetLeft + 25}px`;
                                            attack.style.top = `${bucket.offsetTop + 25}px`;
                                            
                                            battlefield.appendChild(attack);
                                            
                                            // 设置动画到敌人
                                            attack.style.transition = `all 1s cubic-bezier(0.25, 0.46, 0.45, 0.94)`;
                                            
                                            setTimeout(() => {
                                                attack.style.left = `${enemyRect.left - battlefieldRect.left + 40}px`;
                                                attack.style.top = `${enemyRect.top - battlefieldRect.top + 60}px`;
                                                
                                                setTimeout(() => {
                                                    attack.remove();
                                                }, 1000);
                                            }, 10);
                                        }, bucketIndex * 200);
                                    }
                                });
                                
                                // 大爆炸
                                setTimeout(() => {
                                    const bigExplosion = document.createElement('div');
                                    bigExplosion.className = 'explosion';
                                    bigExplosion.style.width = '120px';
                                    bigExplosion.style.height = '120px';
                                    bigExplosion.style.background = 'radial-gradient(circle, #EF4444 0%, #DC2626 100%)';
                                    
                                    bigExplosion.style.left = `${enemyRect.left - battlefieldRect.left - 30}px`;
                                    bigExplosion.style.top = `${enemyRect.top - battlefieldRect.top - 30}px`;
                                    
                                    battlefield.appendChild(bigExplosion);
                                    
                                    setTimeout(() => {
                                        bigExplosion.remove();
                                        
                                        // 清理哈希表
                                        hashTable.forEach(bucket => bucket.remove());
                                    }, 1000);
                                }, 1500);
                            }, 500);
                        }
                    }
                    
                    // 更新桶内容
                    bucket.textContent = bucket.textContent ? bucket.textContent + ',' + element.key : element.key;
                    
                }, index * 500);
            });
        }
        
        // 创建爆炸效果
        function createExplosion(target) {
            const explosion = document.createElement('div');
            explosion.className = 'explosion';
            
            const targetRect = target.getBoundingClientRect();
            const battlefieldRect = document.querySelector('.battlefield').getBoundingClientRect();
            
            explosion.style.left = `${targetRect.left - battlefieldRect.left + 30}px`;
            explosion.style.top = `${targetRect.top - battlefieldRect.top + 30}px`;
            
            document.querySelector('.battlefield').appendChild(explosion);
            
            setTimeout(() => {
                explosion.remove();
            }, 500);
        }
        
        // 创建伤害数字
        function createDamageNumber(damage, target) {
            const damageText = document.createElement('div');
            damageText.className = 'floating-text text-red-500';
            damageText.textContent = `-${damage}`;
            
            const targetRect = target.getBoundingClientRect();
            const battlefieldRect = document.querySelector('.battlefield').getBoundingClientRect();
            
            damageText.style.left = `${targetRect.left - battlefieldRect.left + 40}px`;
            damageText.style.top = `${targetRect.top - battlefieldRect.top}px`;
            
            document.querySelector('.battlefield').appendChild(damageText);
            
            setTimeout(() => {
                damageText.remove();
            }, 1000);
        }
        
        // 敌人攻击
        function enemyAttack() {
            if (gameState.isGameOver) return;
            
            // 播放攻击动画
            enemy.classList.add('animate-attack');
            setTimeout(() => {
                enemy.classList.remove('animate-attack');
            }, 300);
            
            // 创建算法攻击效果
            createAlgorithmAttack();
            
            // 玩家受击动画
            setTimeout(() => {
                player.classList.add('animate-hit');
                setTimeout(() => {
                    player.classList.remove('animate-hit');
                }, 300);
                
                // 创建伤害数字
                createDamageNumber(gameState.enemy.damage, player);
            }, 500);
            
            // 扣除玩家生命值
            gameState.player.health = Math.max(0, gameState.player.health - gameState.enemy.damage);
            
            // 添加战斗日志
            addBattleLog(`${enemyName.textContent} 攻击造成 ${gameState.enemy.damage} 点伤害`);
            
            // 更新UI
            updatePlayerUI();
            
            // 检查玩家是否死亡
            if (gameState.player.health <= 0) {
                endGame(false);
                return;
            }
            
            // 切换回合
            gameState.isPlayerTurn = true;
        }
        
        // 创建算法攻击效果
        function createAlgorithmAttack() {
            const battlefield = document.querySelector('.battlefield');
            const playerRect = player.getBoundingClientRect();
            const battlefieldRect = battlefield.getBoundingClientRect();
            
            // 创建代码片段攻击
            const codeSnippets = [
                'for(;;)',
                'while(1)',
                'sort()',
                'dfs()',
                'bfs()'
            ];
            
            codeSnippets.forEach((snippet, index) => {
                setTimeout(() => {
                    const codeElement = document.createElement('div');
                    codeElement.style.position = 'absolute';
                    codeElement.style.background = 'rgba(6, 182, 212, 0.8)';
                    codeElement.style.color = 'white';
                    codeElement.style.padding = '8px 12px';
                    codeElement.style.borderRadius = '4px';
                    codeElement.style.fontFamily = 'monospace';
                    codeElement.style.fontSize = '14px';
                    codeElement.style.right = '100px';
                    codeElement.style.top = `${100 + index * 40}px`;
                    codeElement.style.opacity = '0';
                    codeElement.textContent = snippet;
                    
                    battlefield.appendChild(codeElement);
                    
                    // 动画
                    codeElement.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    
                    setTimeout(() => {
                        codeElement.style.opacity = '1';
                        codeElement.style.right = `${playerRect.left - battlefieldRect.left + 100}px`;
                        
                        setTimeout(() => {
                            codeElement.style.opacity = '0';
                            setTimeout(() => {
                                codeElement.remove();
                            }, 300);
                        }, 600);
                    }, 10);
                }, index * 200);
            });
        }
        
        // 更新玩家UI
        function updatePlayerUI() {
            playerHealthBar.style.width = `${(gameState.player.health / gameState.player.maxHealth) * 100}%`;
            playerHealthText.textContent = `${gameState.player.health}/${gameState.player.maxHealth}`;
            
            playerEnergyBar.style.width = `${(gameState.player.energy / gameState.player.maxEnergy) * 100}%`;
            playerEnergyText.textContent = `${gameState.player.energy}/${gameState.player.maxEnergy}`;
            
            // 更新技能按钮状态
            updateSkillButtons();
        }
        
        // 更新敌人UI
        function updateEnemyUI() {
            enemyHealthBar.style.width = `${(gameState.enemy.health / gameState.enemy.maxHealth) * 100}%`;
            enemyHealthText.textContent = `${gameState.enemy.health}/${gameState.enemy.maxHealth}`;
        }
        
        // 更新技能按钮
        function updateSkillButtons() {
            const skillButtons = document.querySelectorAll('.skill-button');
            
            skillButtons.forEach(button => {
                const skillType = button.dataset.skill;
                const skill = gameState.player.skills[skillType];
                const cooldown = gameState.player.currentCooldowns[skillType] || 0;
                
                // 移除之前的冷却覆盖层
                const existingOverlay = button.querySelector('.cooldown-overlay');
                if (existingOverlay) existingOverlay.remove();
                
                // 检查能量和冷却
                if (gameState.player.energy < skill.energy || cooldown > 0) {
                    button.classList.add('disabled');
                    
                    // 添加冷却覆盖层
                    const overlay = document.createElement('div');
                    overlay.className = 'cooldown-overlay absolute inset-0 flex items-center justify-center rounded-lg';
                    overlay.textContent = cooldown > 0 ? cooldown : '能量不足';
                    button.style.position = 'relative';
                    button.appendChild(overlay);
                } else {
                    button.classList.remove('disabled');
                }
            });
        }
        
        // 更新冷却
        function updateCooldowns() {
            for (const skillType in gameState.player.currentCooldowns) {
                if (gameState.player.currentCooldowns[skillType] > 0) {
                    gameState.player.currentCooldowns[skillType]--;
                }
            }
            
            updatePlayerUI();
        }
        
        // 添加战斗日志
        function addBattleLog(message, type = 'normal') {
            const logEntry = document.createElement('div');
            
            switch (type) {
                case 'critical':
                    logEntry.className = 'text-yellow-400 font-bold';
                    break;
                case 'warning':
                    logEntry.className = 'text-orange-400';
                    break;
                case 'error':
                    logEntry.className = 'text-red-400';
                    break;
                case 'success':
                    logEntry.className = 'text-green-400';
                    break;
                default:
                    logEntry.className = 'text-gray-300';
            }
            
            logEntry.textContent = `[${formatTime(gameState.countdown)}] ${message}`;
            battleLog.appendChild(logEntry);
            
            // 滚动到底部
            battleLog.scrollTop = battleLog.scrollHeight;
            
            // 限制日志数量
            if (battleLog.children.length > 20) {
                battleLog.removeChild(battleLog.firstChild);
            }
        }
        
        // 格式化时间
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        // 结束游戏
        function endGame(isVictory) {
            gameState.isGameOver = true;
            
            if (isVictory) {
                // 胜利动画
                player.classList.add('animate-victory');
                enemy.style.opacity = '0.5';
                enemy.style.transform = 'rotate(90deg)';
                
                resultIcon.className = 'text-6xl mb-4 text-green-500';
                resultIcon.innerHTML = '<i class="fa fa-trophy"></i>';
                resultTitle.textContent = '战斗胜利！';
                resultMessage.textContent = `你成功击败了 ${enemyName.textContent}！获得了新的技能点。`;
                
                addBattleLog('战斗胜利！', 'success');
                
                // 解锁下一关
                if (gameState.currentLevel < 4) {
                    gameState.currentLevel++;
                } else {
                    gameState.currentChapter++;
                    gameState.currentLevel = 1;
                }
                
                // 解锁新角色（如果是新章节）
                if (gameState.currentLevel === 1 && gameState.currentChapter <= 6) {
                    addBattleLog(`解锁新角色：${getCharacterName(gameState.currentChapter)}`, 'success');
                }
                
            } else {
                // 失败动画
                player.classList.add('animate-defeat');
                player.style.opacity = '0.5';
                
                resultIcon.className = 'text-6xl mb-4 text-red-500';
                resultIcon.innerHTML = '<i class="fa fa-times-circle"></i>';
                resultTitle.textContent = '战斗失败';
                resultMessage.textContent = '不要气馁，继续努力提升你的编程技能！';
                
                addBattleLog('战斗失败！', 'error');
            }
            
            // 显示结果模态框
            setTimeout(() => {
                resultModal.classList.remove('hidden');
            }, 1000);
        }
        
        // 获取角色名称
        function getCharacterName(chapter) {
            const characters = [
                '递归战士',
                '动态规划师',
                '图论大师',
                '数据结构师',
                '算法优化师',
                'CCF主席'
            ];
            return characters[chapter - 1] || '未知角色';
        }
        
        // 禁用右键和Ctrl键
        function disableRightClickAndCtrl() {
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                return false;
            });
            
            document.addEventListener('keydown', (e) => {
                // 禁用Ctrl+S, Ctrl+C, Ctrl+V等
                if (e.ctrlKey) {
                    e.preventDefault();
                    return false;
                }
                
                // 禁用F12, F5等
                if ([123, 116, 115, 119, 122].includes(e.keyCode)) {
                    e.preventDefault();
                    return false;
                }
            });
        }
        
        // 事件监听器
        document.addEventListener('keydown', (e) => {
            if (gameState.isGameOver) return;
            
            switch (e.key.toLowerCase()) {
                case 'w':
                    movePlayer('up');
                    break;
                case 's':
                    movePlayer('down');
                    break;
                case 'a':
                    movePlayer('left');
                    break;
                case 'd':
                    movePlayer('right');
                    break;
                case 'i':
                    if (gameState.isPlayerTurn) {
                        playerAttack('normal');
                    }
                    break;
                case 'j':
                    if (gameState.isPlayerTurn) {
                        playerAttack('skill1');
                    }
                    break;
                case 'k':
                    if (gameState.isPlayerTurn) {
                        playerAttack('skill2');
                    }
                    break;
                case 'l':
                    if (gameState.isPlayerTurn) {
                        playerAttack('skill3');
                    }
                    break;
            }
        });
        
        // 技能按钮点击事件
        document.querySelectorAll('.skill-button').forEach(button => {
            button.addEventListener('click', () => {
                if (gameState.isGameOver || !gameState.isPlayerTurn) return;
                
                const skillType = button.dataset.skill;
                playerAttack(skillType);
            });
        });
        
        // 结果模态框按钮事件
        nextBtn.addEventListener('click', () => {
            // 保存进度
            const userData = JSON.parse(localStorage.getItem('fightCCFUser'));
            if (userData) {
                // 更新解锁的关卡和角色
                if (!userData.unlockedLevels.includes(gameState.currentChapter)) {
                    userData.unlockedLevels.push(gameState.currentChapter);
                }
                if (!userData.unlockedCharacters.includes(gameState.currentChapter)) {
                    userData.unlockedCharacters.push(gameState.currentChapter);
                }
                localStorage.setItem('fightCCFUser', JSON.stringify(userData));
            }
            
            // 跳转到下一关或主页
            if (gameState.currentChapter === 4 && gameState.currentLevel <= 4) {
                window.location.href = 'province.html';
            } else if (gameState.currentChapter === 5) {
                window.location.href = 'noi.html';
            } else {
                window.location.href = 'index.html';
            }
        });
        
        restartBtn.addEventListener('click', () => {
            // 重新开始当前关卡
            location.reload();
        });
        
        homeBtn.addEventListener('click', () => {
            // 返回主页
            window.location.href = 'index.html';
        });
        
        backBtn.addEventListener('click', () => {
            // 返回主页
            window.location.href = 'index.html';
        });
    </script>
</body>
</html>
