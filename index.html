<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¼–ç¨‹æ ¼æ–— - ç«æŸ´äººå¸ƒå¨ƒå¨ƒç‰©ç†æ ¼æ–—æ¸¸æˆ</title>
    <!-- Tailwind CSS v3 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        accent: '#8B5CF6',
                        dark: '#1F2937',
                        light: '#F3F4F6',
                        danger: '#EF4444',
                        warning: '#F59E0B',
                        info: '#3B82F6',
                        success: '#10B981'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace']
                    },
                    animation: {
                        'float': 'float 3s ease-in-out infinite',
                        'pulse-fast': 'pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'glow': 'glow 2s ease-in-out infinite alternate'
                    },
                    keyframes: {
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' }
                        },
                        glow: {
                            '0%': { textShadow: '0 0 5px #fff, 0 0 10px #fff, 0 0 15px #0073e6, 0 0 20px #0073e6' },
                            '100%': { textShadow: '0 0 10px #fff, 0 0 20px #fff, 0 0 30px #0073e6, 0 0 40px #0073e6' }
                        }
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .text-glow {
                text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #0073e6, 0 0 20px #0073e6;
            }
            .text-glow-green {
                text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #00e673, 0 0 20px #00e673;
            }
            .text-glow-red {
                text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #e60000, 0 0 20px #e60000;
            }
            .btn-primary {
                @apply bg-primary hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition-all duration-300;
            }
            .btn-secondary {
                @apply bg-secondary hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-all duration-300;
            }
            .btn-danger {
                @apply bg-danger hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-all duration-300;
            }
            .btn-hover:hover {
                @apply transform scale-105 shadow-lg;
            }
            .menu {
                @apply absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-dark bg-opacity-90 p-8 rounded-xl shadow-2xl border border-gray-700;
            }
            .glass {
                @apply bg-white bg-opacity-10 backdrop-filter backdrop-blur-lg rounded-lg border border-white border-opacity-20;
            }
            .pixel-border {
                @apply border-4 border-white border-opacity-80 rounded-lg shadow-[0_0_0_2px_rgba(0,0,0,0.8)];
            }
        }
    </style>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', system-ui, sans-serif;
        }
        canvas {
            display: block;
            background-color: #000;
        }
        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            pointer-events: none;
            z-index: 10;
        }
        .health-bar, .energy-bar {
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
            background-color: rgba(0, 0, 0, 0.5);
        }
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6666);
            transition: width 0.3s ease;
        }
        .energy-fill {
            height: 100%;
            background: linear-gradient(90deg, #0066ff, #66a3ff);
            transition: width 0.3s ease;
        }
        .slow-motion-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px #0066ff;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .slow-motion-active {
            opacity: 1;
        }
        .control-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 14px;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            pointer-events: none;
        }
        .weapon-indicator {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            pointer-events: none;
        }
        .level-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #0066ff;
            pointer-events: none;
        }
        .enemy-info {
            position: absolute;
            top: 60px;
            left: 50%;
            
        /* é”™è¯¯ä¿¡æ¯æ ·å¼ */
        .error-message {
            background-color: rgba(0, 0, 0, 0.95);
            color: #ff4444;
            padding: 30px;
            border: 2px solid #ff4444;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.5);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }
        
        .error-message h2 {
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff4444;
        }
        
        .error-message p {
            font-size: 18px;
            margin-bottom: 20px;
        }
        
        .error-message button {
            background-color: #660000;
            color: #ff4444;
            border: 2px solid #ff4444;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .error-message button:hover {
            background-color: #ff4444;
            color: #000;
            box-shadow: 0 0 20px #ff4444;
        }
            transform: translateX(-50%);
            color: #fff;
            font-size: 18px;
            text-shadow: 0 0 5px #ff0000;
            pointer-events: none;
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        .digital-rain {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .pixel {
            position: absolute;
            width: 2px;
            height: 2px;
            background-color: #00ff00;
            opacity: 0.5;
            animation: fall linear infinite;
        }
        @keyframes fall {
            0% { transform: translateY(-100vh); }
            100% { transform: translateY(100vh); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- HUD ç•Œé¢ -->
        <div class="hud">
            <div class="flex justify-between items-center mb-4">
                <div class="w-1/3 px-4">
                    <div class="text-white text-sm mb-1">ç©å®¶ç”Ÿå‘½</div>
                    <div class="health-bar pixel-border">
                        <div id="playerHealth" class="health-fill" style="width: 100%;"></div>
                    </div>
                </div>
                <div class="w-1/3 px-4">
                    <div class="text-white text-sm mb-1">ç©å®¶èƒ½é‡</div>
                    <div class="energy-bar pixel-border">
                        <div id="playerEnergy" class="energy-fill" style="width: 100%;"></div>
                    </div>
                </div>
            </div>
            <div class="flex justify-between items-center">
                <div class="w-1/3 px-4">
                    <div class="text-white text-sm mb-1">æ•Œäººç”Ÿå‘½</div>
                    <div class="health-bar pixel-border">
                        <div id="enemyHealth" class="health-fill" style="width: 100%;"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- æ…¢åŠ¨ä½œæŒ‡ç¤ºå™¨ -->
        <div id="slowMotionIndicator" class="slow-motion-indicator">
            <i class="fa fa-clock-o mr-2"></i>æ…¢åŠ¨ä½œæ¨¡å¼
        </div>
        
        <!-- æ§åˆ¶æç¤º -->
        <div class="control-hint">
            <div>A/D - ç§»åŠ¨ | J/L - æ”»å‡» | K - è·³è·ƒ | ç©ºæ ¼ - æ…¢åŠ¨ä½œ | 1-6 - åˆ‡æ¢æ­¦å™¨</div>
            <div class="mt-2">é¼ æ ‡æ‹–æ‹½è§’è‰²éƒ¨ä½è¿›è¡Œæ“ä½œ</div>
        </div>
        
        <!-- æ­¦å™¨æŒ‡ç¤ºå™¨ -->
        <div id="weaponIndicator" class="weapon-indicator">
            å½“å‰æ­¦å™¨: <span id="currentWeapon">æ‹³å¤´</span>
        </div>
        
        <!-- å…³å¡ä¿¡æ¯ -->
        <div id="levelInfo" class="level-info">
            å…³å¡ <span id="currentLevel">1</span>
        </div>
        
        <!-- æ•Œäººä¿¡æ¯ -->
        <div id="enemyInfo" class="enemy-info">
            <span id="enemyName">CSP-J é€‰æ‰‹</span>
        </div>
        
        <!-- æ•°å­—é›¨èƒŒæ™¯ -->
        <div id="digitalRain" class="digital-rain"></div>
    </div>
    
    <!-- ä¸»èœå• -->
    <div id="mainMenu" class="menu fade-in">
        <h1 class="text-5xl font-bold text-white mb-8 text-center text-glow">ç¼–ç¨‹æ ¼æ–—</h1>
        <h2 class="text-2xl text-blue-400 mb-8 text-center">ç«æŸ´äººå¸ƒå¨ƒå¨ƒç‰©ç†æ ¼æ–—æ¸¸æˆ</h2>
        <div class="flex flex-col gap-4 w-64 mx-auto">
            <button id="startGameBtn" class="btn-primary btn-hover">å¼€å§‹æ¸¸æˆ</button>
            <button id="levelSelectBtn" class="btn-secondary btn-hover">é€‰æ‹©å…³å¡</button>
            <button id="controlsBtn" class="btn-info btn-hover">æ“ä½œè¯´æ˜</button>
        </div>
    </div>
    
    <!-- å…³å¡é€‰æ‹© -->
    <div id="levelSelect" class="menu hidden">
        <h2 class="text-3xl font-bold text-white mb-6 text-center text-glow">é€‰æ‹©å…³å¡</h2>
        <div class="grid grid-cols-2 gap-4 w-80 mx-auto">
            <button class="difficulty-btn btn-primary btn-hover" data-level="1">
                å…³å¡ 1: CSP-J é€‰æ‰‹
            </button>
            <button class="difficulty-btn btn-primary btn-hover locked" data-level="2">
                <span class="lock-icon mr-2">ğŸ”’</span>å…³å¡ 2: CSP-S é€‰æ‰‹
            </button>
            <button class="difficulty-btn btn-primary btn-hover locked" data-level="3">
                <span class="lock-icon mr-2">ğŸ”’</span>å…³å¡ 3: NOIP é€‰æ‰‹
            </button>
            <button class="difficulty-btn btn-primary btn-hover locked" data-level="4">
                <span class="lock-icon mr-2">ğŸ”’</span>å…³å¡ 4: çœé€‰é€‰æ‰‹
            </button>
            <button class="difficulty-btn btn-primary btn-hover locked" data-level="5">
                <span class="lock-icon mr-2">ğŸ”’</span>å…³å¡ 5: NOI é€‰æ‰‹
            </button>
            <button class="difficulty-btn btn-primary btn-hover locked" data-level="6">
                <span class="lock-icon mr-2">ğŸ”’</span>å…³å¡ 6: CCF ä¸»å¸­
            </button>
        </div>
        <div class="mt-6 text-center">
            <button id="backToMenuBtn" class="btn-danger btn-hover">è¿”å›ä¸»èœå•</button>
        </div>
    </div>
    
    <!-- æ“ä½œè¯´æ˜ -->
    <div id="controlsMenu" class="menu hidden">
        <h2 class="text-3xl font-bold text-white mb-6 text-center text-glow">æ“ä½œè¯´æ˜</h2>
        <div class="text-white mb-6">
            <h3 class="text-xl font-bold mb-2">åŸºæœ¬æ“ä½œ:</h3>
            <ul class="list-disc pl-6 space-y-2">
                <li>A/D é”® - å·¦å³ç§»åŠ¨</li>
                <li>J/L é”® - å·¦å³æ”»å‡»</li>
                <li>K é”® - è·³è·ƒ</li>
                <li>ç©ºæ ¼é”® - æ…¢åŠ¨ä½œæ¨¡å¼ï¼ˆå†·å´1ç§’ï¼‰</li>
                <li>1-6 æ•°å­—é”® - åˆ‡æ¢æ­¦å™¨</li>
            </ul>
            <h3 class="text-xl font-bold mb-2 mt-4">é¼ æ ‡æ“ä½œ:</h3>
            <ul class="list-disc pl-6 space-y-2">
                <li>æ‹–æ‹½è§’è‰²å¤´éƒ¨ - æ§åˆ¶å¤´éƒ¨åŠ¨ä½œ</li>
                <li>æ‹–æ‹½è§’è‰²æ‰‹è‡‚ - è¿›è¡Œæ‹³å‡»æ”»å‡»</li>
                <li>æ‹–æ‹½è§’è‰²è…¿éƒ¨ - è¿›è¡Œè¸¢å‡»æˆ–è·³è·ƒ</li>
                <li>æ‹–æ‹½è§’è‰²èº«ä½“ - æ•´ä½“ç§»åŠ¨</li>
            </ul>
            <h3 class="text-xl font-bold mb-2 mt-4">æ¸¸æˆè§„åˆ™:</h3>
            <ul class="list-disc pl-6 space-y-2">
                <li>æŒ‰é¡ºåºæŒ‘æˆ˜6ä¸ªå…³å¡</li>
                <li>å‡»è´¥å½“å‰å…³å¡æ‰èƒ½è§£é”ä¸‹ä¸€å…³</li>
                <li>ä»»ä½•å…³å¡å¤±è´¥éƒ½ä¼šé‡ç½®è¿›åº¦</li>
                <li>åˆç†ä½¿ç”¨æ…¢åŠ¨ä½œå’Œæ­¦å™¨ç³»ç»Ÿ</li>
            </ul>
        </div>
        <div class="text-center">
            <button id="closeControlsBtn" class="btn-primary btn-hover">å…³é—­</button>
        </div>
    </div>
    
    <!-- æ¸¸æˆç»“æŸ -->
    <div id="gameOver" class="menu hidden">
        <h2 class="text-4xl font-bold text-red-500 mb-4 text-center text-glow-red">æ¸¸æˆç»“æŸ</h2>
        <p class="text-white text-xl mb-6 text-center">ä½ è¢« <span id="defeatedBy">CSP-J é€‰æ‰‹</span> å‡»è´¥äº†</p>
        <p class="text-white mb-6 text-center">è¿›åº¦å·²é‡ç½®ï¼Œéœ€è¦ä»å¤´å¼€å§‹æŒ‘æˆ˜</p>
        <div class="text-center">
            <button id="restartGameBtn" class="btn-primary btn-hover">é‡æ–°å¼€å§‹</button>
        </div>
    </div>
    
    <!-- èƒœåˆ©ç•Œé¢ -->
    <div id="victory" class="menu hidden">
        <h2 class="text-4xl font-bold text-green-500 mb-4 text-center text-glow-green">èƒœåˆ©ï¼</h2>
        <p class="text-white text-xl mb-6 text-center">ä½ å‡»è´¥äº† <span id="victoryEnemy">CSP-J é€‰æ‰‹</span></p>
        <div id="nextLevelInfo" class="text-white mb-6 text-center">
            å…³å¡ <span id="nextLevelNum">2</span> å·²è§£é”ï¼
        </div>
        <div class="text-center">
            <button id="nextLevelBtn" class="btn-primary btn-hover">è¿›å…¥ä¸‹ä¸€å…³</button>
        </div>
    </div>

    <script>
        // è·å–ç”»å¸ƒå’Œä¸Šä¸‹æ–‡
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // è®¾ç½®ç”»å¸ƒå°ºå¯¸
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // æ¸¸æˆçŠ¶æ€
        const gameState = {
            currentScreen: 'mainMenu',
            selectedLevel: 1,
            currentLevel: 1,
            maxLevel: 6,
            completedLevels: [],
            isGameRunning: false,
            slowMotionActive: false,
            slowMotionCooldown: 0,
            stage: {
                background: new Image()
            },
            mouse: {
                x: 0,
                y: 0,
                isDown: false,
                lastX: 0,
                lastY: 0,
                draggingPart: null,
                dragOffsetX: 0,
                dragOffsetY: 0
            },
            physics: {
                gravity: 0.8,
                friction: 0.95,
                bounce: 0.2,
                jointStiffness: 0.9,
                ragdollForce: 10,
                maxAngularVelocity: 10
            },
            player: {
                health: 100,
                energy: 100,
                x: 200,
                y: 450,
                width: 80,
                height: 150,
                speed: 5,
                direction: 'right',
                ragdoll: {
                    head: { x: 0, y: -70, radius: 20, angle: 0, angularVelocity: 0, isDragging: false },
                    torso: { x: 0, y: -20, width: 30, height: 60, angle: 0, angularVelocity: 0, isDragging: false },
                    leftArm: { x: -25, y: -10, length: 50, angle: -30 * Math.PI / 180, angularVelocity: 0, joint: { x: -15, y: -10 }, isDragging: false },
                    rightArm: { x: 25, y: -10, length: 50, angle: 30 * Math.PI / 180, angularVelocity: 0, joint: { x: 15, y: -10 }, isDragging: false },
                    leftLeg: { x: -10, y: 30, length: 70, angle: 15 * Math.PI / 180, angularVelocity: 0, joint: { x: -10, y: 20 }, isDragging: false },
                    rightLeg: { x: 10, y: 30, length: 70, angle: -15 * Math.PI / 180, angularVelocity: 0, joint: { x: 10, y: 20 }, isDragging: false }
                },
                currentWeapon: 'fist',
                weapons: {
                    fist: { name: 'æ‹³å¤´', damage: 10, range: 50, energyCost: 0 },
                    binarySearch: { name: 'äºŒåˆ†æŸ¥æ‰¾', damage: 15, range: 80, energyCost: 10 },
                    treeArray: { name: 'æ ‘çŠ¶æ•°ç»„', damage: 20, range: 60, energyCost: 15 },
                    unionFind: { name: 'å¹¶æŸ¥é›†', damage: 25, range: 50, energyCost: 20 },
                    dynamicProgramming: { name: 'åŠ¨æ€è§„åˆ’', damage: 30, range: 70, energyCost: 25 },
                    dfs: { name: 'æ·±åº¦ä¼˜å…ˆæœç´¢', damage: 35, range: 90, energyCost: 30 }
                },
                lastAttackTime: 0,
                isGrounded: true
            },
            enemy: {
                health: 100,
                x: 600,
                y: 450,
                width: 80,
                height: 150,
                speed: 3,
                direction: 'left',
                ragdoll: {
                    head: { x: 0, y: -70, radius: 20, angle: 0, angularVelocity: 0 },
                    torso: { x: 0, y: -20, width: 30, height: 60, angle: 0, angularVelocity: 0 },
                    leftArm: { x: -25, y: -10, length: 50, angle: -30 * Math.PI / 180, angularVelocity: 0, joint: { x: -15, y: -10 } },
                    rightArm: { x: 25, y: -10, length: 50, angle: 30 * Math.PI / 180, angularVelocity: 0, joint: { x: 15, y: -10 } },
                    leftLeg: { x: -10, y: 30, length: 70, angle: 15 * Math.PI / 180, angularVelocity: 0, joint: { x: -10, y: 20 } },
                    rightLeg: { x: 10, y: 30, length: 70, angle: -15 * Math.PI / 180, angularVelocity: 0, joint: { x: 10, y: 20 } }
                },
                difficulty: 1,
                actionCooldown: 0,
                lastActionTime: 0,
                isGrounded: true
            },
            keys: {
                a: false,
                d: false,
                j: false,
                k: false,
                l: false,
                space: false
            },
            effects: [],
            stage: {
                background: new Image(),
                digitalRain: []
            },
            levelData: [
                { name: 'CSP-J é€‰æ‰‹', health: 100, speed: 3, damage: 8, difficulty: 1 },
                { name: 'CSP-S é€‰æ‰‹', health: 120, speed: 4, damage: 10, difficulty: 2 },
                { name: 'NOIP é€‰æ‰‹', health: 140, speed: 4, damage: 12, difficulty: 3 },
                { name: 'çœé€‰é€‰æ‰‹', health: 160, speed: 5, damage: 14, difficulty: 4 },
                { name: 'NOI é€‰æ‰‹', health: 180, speed: 5, damage: 16, difficulty: 5 },
                { name: 'CCF ä¸»å¸­', health: 200, speed: 6, damage: 20, difficulty: 6 }
            ]
        };
        
        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            try {
                console.log('åˆå§‹åŒ–æ¸¸æˆ...');
                
                // éªŒè¯gameStateæ˜¯å¦å­˜åœ¨
                if (!gameState) {
                    throw new Error('æ¸¸æˆçŠ¶æ€æœªæ­£ç¡®åˆå§‹åŒ–');
                }
                
                // ç¡®ä¿stageå¯¹è±¡å­˜åœ¨
                if (!gameState.stage) {
                    gameState.stage = {
                        background: new Image()
                    };
                }
                
                // è®¾ç½®èƒŒæ™¯å›¾ç‰‡
                gameState.stage.background.src = "https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/rc/pc/super_tool/7fa66471e738478aae30f6370710e285~tplv-a9rns2rl98-image.image?rcl=20251206161902CAE92BAA05DBF23A092F&rk3s=8e244e95&rrcfp=f06b921b&x-expires=1767601153&x-signature=%2FpLIYZEW0XtI9vfAEUcUDy1aYm8%3D";
                
                // é¢„åŠ è½½èƒŒæ™¯å›¾ç‰‡
                gameState.stage.background.onload = function() {
                    console.log('èƒŒæ™¯å›¾ç‰‡åŠ è½½å®Œæˆ');
                };
                
                gameState.stage.background.onerror = function() {
                    console.error('èƒŒæ™¯å›¾ç‰‡åŠ è½½å¤±è´¥');
                    // ä½¿ç”¨å¤‡ç”¨èƒŒæ™¯è‰²
                    document.body.style.backgroundColor = '#0a1929';
                };
                
                // åˆå§‹åŒ–æ•°å­—é›¨
                initDigitalRain();
                
                // åˆå§‹åŒ–å¸ƒå¨ƒå¨ƒç‰©ç†
                if (gameState.player && gameState.enemy) {
                    initRagdollPhysics(gameState.player);
                    initRagdollPhysics(gameState.enemy);
                } else {
                    throw new Error('ç©å®¶æˆ–æ•Œäººå¯¹è±¡ä¸å­˜åœ¨');
                }
                
                // åŠ è½½å…³å¡æ•°æ®
                loadLevel(gameState.currentLevel);
            } catch (error) {
                console.error('æ¸¸æˆåˆå§‹åŒ–é”™è¯¯:', error);
                console.error('é”™è¯¯å †æ ˆ:', error.stack);
                
                // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯ç»™ç”¨æˆ·
                const gameContainer = document.getElementById('game-container');
                if (gameContainer) {
                    gameContainer.innerHTML = `
                        <div class="error-message">
                            <h2>æ¸¸æˆåˆå§‹åŒ–å¤±è´¥</h2>
                            <p>è¯·åˆ·æ–°é¡µé¢é‡è¯•</p>
                            <button onclick="location.reload()">åˆ·æ–°é¡µé¢</button>
                        </div>
                    `;
                }
            }
            
            console.log('æ¸¸æˆåˆå§‹åŒ–å®Œæˆ');
        }
        
        // åˆå§‹åŒ–å¸ƒå¨ƒå¨ƒç‰©ç†ç³»ç»Ÿ
        function initRagdollPhysics(character) {
            // è®¾ç½®åˆå§‹è§’åº¦å’Œè§’é€Ÿåº¦
            character.ragdoll.head.angle = 0;
            character.ragdoll.head.angularVelocity = 0;
            character.ragdoll.torso.angle = 0;
            character.ragdoll.torso.angularVelocity = 0;
            character.ragdoll.leftArm.angle = -30 * Math.PI / 180;
            character.ragdoll.leftArm.angularVelocity = 0;
            character.ragdoll.rightArm.angle = 30 * Math.PI / 180;
            character.ragdoll.rightArm.angularVelocity = 0;
            character.ragdoll.leftLeg.angle = 15 * Math.PI / 180;
            character.ragdoll.leftLeg.angularVelocity = 0;
            character.ragdoll.rightLeg.angle = -15 * Math.PI / 180;
            character.ragdoll.rightLeg.angularVelocity = 0;
        }
        
        // åŠ è½½å…³å¡
        function loadLevel(level) {
            const levelData = gameState.levelData[level - 1];
            if (!levelData) return;
            
            // é‡ç½®ç©å®¶çŠ¶æ€
            gameState.player.health = 100;
            gameState.player.energy = 100;
            gameState.player.x = 200;
            gameState.player.y = 450;
            gameState.player.isGrounded = true;
            initRagdollPhysics(gameState.player);
            
            // è®¾ç½®æ•ŒäººçŠ¶æ€
            gameState.enemy.health = levelData.health;
            gameState.enemy.speed = levelData.speed;
            gameState.enemy.damage = levelData.damage;
            gameState.enemy.difficulty = levelData.difficulty;
            gameState.enemy.x = 600;
            gameState.enemy.y = 450;
            gameState.enemy.isGrounded = true;
            gameState.enemy.name = levelData.name;
            initRagdollPhysics(gameState.enemy);
            
            // æ›´æ–°UI
            document.getElementById('currentLevel').textContent = level;
            document.getElementById('enemyName').textContent = levelData.name;
            updateHUD();
        }
        
        // æ£€æŸ¥ç¢°æ’
        function checkCollisions() {
            try {
                // æ£€æŸ¥ç©å®¶å’Œæ•Œäººæ˜¯å¦ç¢°æ’
                const player = gameState.player;
                const enemy = gameState.enemy;
                
                // éªŒè¯å¯¹è±¡å­˜åœ¨
                if (!player || !enemy || !player.ragdoll || !enemy.ragdoll) {
                    console.error('ç©å®¶æˆ–æ•Œäººå¯¹è±¡ä¸å­˜åœ¨');
                    return;
                }
                
                const playerLeft = player.x - player.width / 2;
                const playerRight = player.x + player.width / 2;
                const playerTop = player.y - player.height / 2;
                const playerBottom = player.y + player.height / 2;
                
                const enemyLeft = enemy.x - enemy.width / 2;
                const enemyRight = enemy.x + enemy.width / 2;
                const enemyTop = enemy.y - enemy.height / 2;
                const enemyBottom = enemy.y + enemy.height / 2;
                
                // ç®€å•çš„çŸ©å½¢ç¢°æ’æ£€æµ‹
                if (playerRight > enemyLeft && 
                    playerLeft < enemyRight && 
                    playerBottom > enemyTop && 
                    playerTop < enemyBottom) {
                    
                    // åˆ†ç¦»ç©å®¶å’Œæ•Œäºº
                    const overlapX = Math.min(playerRight - enemyLeft, enemyRight - playerLeft);
                    const overlapY = Math.min(playerBottom - enemyTop, enemyBottom - playerTop);
                    
                    if (overlapX < overlapY) {
                        // æ°´å¹³åˆ†ç¦»
                        if (player.x < enemy.x) {
                            player.x -= overlapX / 2;
                            enemy.x += overlapX / 2;
                        } else {
                            player.x += overlapX / 2;
                            enemy.x -= overlapX / 2;
                        }
                        
                        // æ·»åŠ ç¢°æ’æ•ˆæœ
                        player.ragdoll.torso.angularVelocity += 0.3;
                        enemy.ragdoll.torso.angularVelocity -= 0.3;
                    } else {
                        // å‚ç›´åˆ†ç¦»
                        if (player.y < enemy.y) {
                            player.y -= overlapY / 2;
                            enemy.y += overlapY / 2;
                        } else {
                            player.y += overlapY / 2;
                            enemy.y -= overlapY / 2;
                        }
                        
                        // æ·»åŠ ç¢°æ’æ•ˆæœ
                        player.ragdoll.head.angularVelocity += 0.2;
                        enemy.ragdoll.head.angularVelocity -= 0.2;
                    }
                }
                
                // æ£€æŸ¥åœ°é¢ç¢°æ’
                if (player.y > 450) {
                    player.y = 450;
                    player.isGrounded = true;
                }
                
                if (enemy.y > 450) {
                    enemy.y = 450;
                    enemy.isGrounded = true;
                }
                
            } catch (error) {
                console.error('ç¢°æ’æ£€æµ‹é”™è¯¯:', error);
            }
        }
        
        // æ›´æ–°å¸ƒå¨ƒå¨ƒç‰©ç†
        function updateRagdollPhysics(character, dt) {
            const physics = gameState.physics;
            const slowMo = gameState.slowMotionActive ? 0.2 : 1;
            const deltaTime = dt * slowMo;
            
            // æ›´æ–°è§’é€Ÿåº¦ï¼ˆç®€åŒ–çš„ç‰©ç†æ¨¡æ‹Ÿï¼‰
            character.ragdoll.head.angularVelocity *= physics.friction;
            character.ragdoll.torso.angularVelocity *= physics.friction;
            character.ragdoll.leftArm.angularVelocity *= physics.friction;
            character.ragdoll.rightArm.angularVelocity *= physics.friction;
            character.ragdoll.leftLeg.angularVelocity *= physics.friction;
            character.ragdoll.rightLeg.angularVelocity *= physics.friction;
            
            // åº”ç”¨é‡åŠ›å½±å“ï¼ˆå¦‚æœåœ¨ç©ºä¸­ï¼‰
            if (!character.isGrounded) {
                character.ragdoll.leftLeg.angularVelocity += physics.gravity * 0.01 * deltaTime;
                character.ragdoll.rightLeg.angularVelocity -= physics.gravity * 0.01 * deltaTime;
            }
            
            // æ›´æ–°è§’åº¦
            character.ragdoll.head.angle += character.ragdoll.head.angularVelocity * deltaTime;
            character.ragdoll.torso.angle += character.ragdoll.torso.angularVelocity * deltaTime;
            character.ragdoll.leftArm.angle += character.ragdoll.leftArm.angularVelocity * deltaTime;
            character.ragdoll.rightArm.angle += character.ragdoll.rightArm.angularVelocity * deltaTime;
            character.ragdoll.leftLeg.angle += character.ragdoll.leftLeg.angularVelocity * deltaTime;
            character.ragdoll.rightLeg.angle += character.ragdoll.rightLeg.angularVelocity * deltaTime;
            
            // çº¦æŸï¼šä¿æŒèº«ä½“éƒ¨ä½ç›¸å¯¹åˆç†çš„è§’åº¦èŒƒå›´
            character.ragdoll.head.angle = Math.max(-Math.PI/4, Math.min(Math.PI/4, character.ragdoll.head.angle));
            character.ragdoll.torso.angle = Math.max(-Math.PI/6, Math.min(Math.PI/6, character.ragdoll.torso.angle));
            character.ragdoll.leftArm.angle = Math.max(-Math.PI*3/4, Math.min(Math.PI*3/4, character.ragdoll.leftArm.angle));
            character.ragdoll.rightArm.angle = Math.max(-Math.PI*3/4, Math.min(Math.PI*3/4, character.ragdoll.rightArm.angle));
            character.ragdoll.leftLeg.angle = Math.max(-Math.PI/3, Math.min(Math.PI/3, character.ragdoll.leftLeg.angle));
            character.ragdoll.rightLeg.angle = Math.max(-Math.PI/3, Math.min(Math.PI/3, character.ragdoll.rightLeg.angle));
            
            // é™åˆ¶æœ€å¤§è§’é€Ÿåº¦
            character.ragdoll.head.angularVelocity = Math.max(-physics.maxAngularVelocity, Math.min(physics.maxAngularVelocity, character.ragdoll.head.angularVelocity));
            character.ragdoll.torso.angularVelocity = Math.max(-physics.maxAngularVelocity, Math.min(physics.maxAngularVelocity, character.ragdoll.torso.angularVelocity));
            character.ragdoll.leftArm.angularVelocity = Math.max(-physics.maxAngularVelocity, Math.min(physics.maxAngularVelocity, character.ragdoll.leftArm.angularVelocity));
            character.ragdoll.rightArm.angularVelocity = Math.max(-physics.maxAngularVelocity, Math.min(physics.maxAngularVelocity, character.ragdoll.rightArm.angularVelocity));
            character.ragdoll.leftLeg.angularVelocity = Math.max(-physics.maxAngularVelocity, Math.min(physics.maxAngularVelocity, character.ragdoll.leftLeg.angularVelocity));
            character.ragdoll.rightLeg.angularVelocity = Math.max(-physics.maxAngularVelocity, Math.min(physics.maxAngularVelocity, character.ragdoll.rightLeg.angularVelocity));
        }
        
        // åº”ç”¨åŠ›åˆ°å¸ƒå¨ƒå¨ƒéƒ¨ä½
        function applyForceToRagdoll(character, bodyPart, forceX, forceY) {
            try {
                // éªŒè¯å‚æ•°
                if (!character || !character.ragdoll || !bodyPart) {
                    console.error('åº”ç”¨åŠ›é‡å‚æ•°æ— æ•ˆ:', character, bodyPart);
                    return;
                }
                
                const physics = gameState.physics;
                const force = Math.sqrt(forceX * forceX + forceY * forceY);
                const torque = force * physics.ragdollForce * 0.01;
                
                // é™åˆ¶æœ€å¤§åŠ›é‡
                const maxForce = 50;
                const clampedForce = Math.min(force, maxForce);
                const scaledTorque = (clampedForce / force) * torque;
                
                // æ ¹æ®åŠ›çš„æ–¹å‘åº”ç”¨æ‰­çŸ©
                if (bodyPart === 'head' && character.ragdoll.head) {
                    character.ragdoll.head.angularVelocity += scaledTorque * Math.sign(forceX);
                    if (character.ragdoll.torso) character.ragdoll.torso.angularVelocity += scaledTorque * 0.3 * Math.sign(forceX);
                } else if (bodyPart === 'torso' && character.ragdoll.torso) {
                    character.ragdoll.torso.angularVelocity += scaledTorque * Math.sign(forceX);
                    if (character.ragdoll.head) character.ragdoll.head.angularVelocity += scaledTorque * 0.5 * Math.sign(forceX);
                    if (character.ragdoll.leftArm) character.ragdoll.leftArm.angularVelocity += scaledTorque * 0.2 * Math.sign(forceX);
                    if (character.ragdoll.rightArm) character.ragdoll.rightArm.angularVelocity += scaledTorque * 0.2 * Math.sign(forceX);
                } else if (bodyPart === 'leftArm' && character.ragdoll.leftArm) {
                    character.ragdoll.leftArm.angularVelocity += scaledTorque * Math.sign(forceY);
                } else if (bodyPart === 'rightArm' && character.ragdoll.rightArm) {
                    character.ragdoll.rightArm.angularVelocity += scaledTorque * Math.sign(forceY);
                } else if (bodyPart === 'leftLeg' && character.ragdoll.leftLeg) {
                    character.ragdoll.leftLeg.angularVelocity += scaledTorque * Math.sign(forceY);
                    if (character.isGrounded) {
                        character.y -= 30; // å¢åŠ è·³è·ƒé«˜åº¦
                        character.isGrounded = false;
                    }
                } else if (bodyPart === 'rightLeg' && character.ragdoll.rightLeg) {
                    character.ragdoll.rightLeg.angularVelocity += scaledTorque * Math.sign(forceY);
                    if (character.isGrounded) {
                        character.y -= 30; // å¢åŠ è·³è·ƒé«˜åº¦
                        character.isGrounded = false;
                    }
                }
            } catch (error) {
                console.error('åº”ç”¨åŠ›é‡åˆ°å¸ƒå¨ƒå¨ƒæ—¶å‡ºé”™:', error);
                console.error('é”™è¯¯å †æ ˆ:', error.stack);
            }
        }
        
        // æ£€æµ‹é¼ æ ‡æ˜¯å¦åœ¨å¸ƒå¨ƒå¨ƒéƒ¨ä½ä¸Š
        function getRagdollPartAtPosition(character, x, y) {
            const parts = ['head', 'torso', 'leftArm', 'rightArm', 'leftLeg', 'rightLeg'];
            
            for (const part of parts) {
                const partData = character.ragdoll[part];
                let partX = character.x + partData.x;
                let partY = character.y + partData.y;
                
                // è®¡ç®—éƒ¨ä½çš„ä¸–ç•Œåæ ‡
                if (part === 'head') {
                    partX += Math.sin(character.ragdoll.torso.angle) * 30;
                    partY += Math.cos(character.ragdoll.torso.angle) * 30;
                } else if (part === 'leftArm' || part === 'rightArm') {
                    const jointX = character.x + partData.joint.x;
                    const jointY = character.y + partData.joint.y;
                    partX = jointX + Math.sin(partData.angle) * partData.length;
                    partY = jointY + Math.cos(partData.angle) * partData.length;
                } else if (part === 'leftLeg' || part === 'rightLeg') {
                    const jointX = character.x + partData.joint.x;
                    const jointY = character.y + partData.joint.y;
                    partX = jointX + Math.sin(partData.angle) * partData.length;
                    partY = jointY + Math.cos(partData.angle) * partData.length;
                }
                
                // ç®€å•çš„åœ†å½¢ç¢°æ’æ£€æµ‹
                const distance = Math.sqrt((x - partX) ** 2 + (y - partY) ** 2);
                const radius = part === 'head' ? partData.radius : 15;
                
                if (distance <= radius) {
                    return {
                        part: part,
                        offsetX: x - partX,
                        offsetY: y - partY
                    };
                }
            }
            
            return null;
        }
        
        // é¼ æ ‡äº‹ä»¶å¤„ç†
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            gameState.mouse.isDown = true;
            gameState.mouse.lastX = mouseX;
            gameState.mouse.lastY = mouseY;
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†ç©å®¶çš„å¸ƒå¨ƒå¨ƒéƒ¨ä½
            const playerPart = getRagdollPartAtPosition(gameState.player, mouseX, mouseY);
            if (playerPart) {
                gameState.mouse.draggingPart = {
                    character: 'player',
                    part: playerPart.part,
                    offsetX: playerPart.offsetX,
                    offsetY: playerPart.offsetY
                };
                gameState.player.ragdoll[playerPart.part].isDragging = true;
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†æ•Œäººçš„å¸ƒå¨ƒå¨ƒéƒ¨ä½
            const enemyPart = getRagdollPartAtPosition(gameState.enemy, mouseX, mouseY);
            if (enemyPart) {
                gameState.mouse.draggingPart = {
                    character: 'enemy',
                    part: enemyPart.part,
                    offsetX: enemyPart.offsetX,
                    offsetY: enemyPart.offsetY
                };
                gameState.enemy.ragdoll[enemyPart.part].isDragging = true;
            }
        }
        
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            gameState.mouse.x = mouseX;
            gameState.mouse.y = mouseY;
            
            if (gameState.mouse.isDown && gameState.mouse.draggingPart) {
                const dragPart = gameState.mouse.draggingPart;
                const character = dragPart.character === 'player' ? gameState.player : gameState.enemy;
                const part = dragPart.part;
                
                // è®¡ç®—æ‹–æ‹½çš„åŠ›
                const forceX = mouseX - gameState.mouse.lastX;
                const forceY = mouseY - gameState.mouse.lastY;
                
                // åº”ç”¨åŠ›åˆ°å¸ƒå¨ƒå¨ƒéƒ¨ä½
                applyForceToRagdoll(character, part, forceX, forceY);
                
                // æ›´æ–°é¼ æ ‡ä½ç½®
                gameState.mouse.lastX = mouseX;
                gameState.mouse.lastY = mouseY;
            }
        }
        
        function handleMouseUp(e) {
            gameState.mouse.isDown = false;
            
            if (gameState.mouse.draggingPart) {
                const dragPart = gameState.mouse.draggingPart;
                const character = dragPart.character === 'player' ? gameState.player : gameState.enemy;
                const part = dragPart.part;
                
                character.ragdoll[part].isDragging = false;
                gameState.mouse.draggingPart = null;
            }
        }
        
        // é”®ç›˜äº‹ä»¶å¤„ç†
        function handleKeyDown(e) {
            switch(e.key.toLowerCase()) {
                case 'a':
                    gameState.keys.a = true;
                    gameState.player.direction = 'left';
                    break;
                case 'd':
                    gameState.keys.d = true;
                    gameState.player.direction = 'right';
                    break;
                case 'j':
                    gameState.keys.j = true;
                    // å·¦æ‹³æ”»å‡»
                    if (gameState.isGameRunning) {
                        attack(gameState.player, 'left');
                    }
                    break;
                case 'k':
                    gameState.keys.k = true;
                    // è·³è·ƒ
                    if (gameState.isGameRunning && gameState.player.isGrounded) {
                        gameState.player.y -= 100;
                        gameState.player.isGrounded = false;
                        // åº”ç”¨è·³è·ƒåŠ›åˆ°è…¿éƒ¨
                        applyForceToRagdoll(gameState.player, 'leftLeg', 0, -20);
                        applyForceToRagdoll(gameState.player, 'rightLeg', 0, -20);
                    }
                    break;
                case 'l':
                    gameState.keys.l = true;
                    // å³æ‹³æ”»å‡»
                    if (gameState.isGameRunning) {
                        attack(gameState.player, 'right');
                    }
                    break;
                case ' ':
                    e.preventDefault();
                    // æ…¢åŠ¨ä½œåŠŸèƒ½
                    if (gameState.isGameRunning && gameState.slowMotionCooldown === 0) {
                        gameState.slowMotionActive = !gameState.slowMotionActive;
                        gameState.slowMotionCooldown = 60; // 1ç§’å†·å´ï¼ˆ60å¸§ï¼‰
                        updateSlowMotionUI();
                    } else if (gameState.currentScreen === 'mainMenu') {
                        startGame();
                    } else if (gameState.currentScreen === 'levelSelect') {
                        startGame();
                    } else if (gameState.currentScreen === 'gameOver') {
                        gameState.currentScreen = 'mainMenu';
                        showScreen('mainMenu');
                    } else if (gameState.currentScreen === 'victory') {
                        nextLevel();
                    }
                    break;
                case '1':
                    gameState.player.currentWeapon = 'fist';
                    updateWeaponUI();
                    break;
                case '2':
                    gameState.player.currentWeapon = 'binarySearch';
                    updateWeaponUI();
                    break;
                case '3':
                    gameState.player.currentWeapon = 'treeArray';
                    updateWeaponUI();
                    break;
                case '4':
                    gameState.player.currentWeapon = 'unionFind';
                    updateWeaponUI();
                    break;
                case '5':
                    gameState.player.currentWeapon = 'dynamicProgramming';
                    updateWeaponUI();
                    break;
                case '6':
                    gameState.player.currentWeapon = 'dfs';
                    updateWeaponUI();
                    break;
            }
        }
        
        function handleKeyUp(e) {
            switch(e.key.toLowerCase()) {
                case 'a':
                    gameState.keys.a = false;
                    break;
                case 'd':
                    gameState.keys.d = false;
                    break;
                case 'j':
                    gameState.keys.j = false;
                    break;
                case 'k':
                    gameState.keys.k = false;
                    break;
                case 'l':
                    gameState.keys.l = false;
                    break;
            }
        }
        
        // æ”»å‡»å‡½æ•°
        function attack(attacker, side) {
            const currentTime = Date.now();
            const weapon = attacker.weapons[attacker.currentWeapon];
            
            // æ£€æŸ¥èƒ½é‡æ¶ˆè€—
            if (attacker.energy < weapon.energyCost) {
                console.log('èƒ½é‡ä¸è¶³ï¼Œæ— æ³•æ”»å‡»');
                return;
            }
            
            // æ£€æŸ¥æ”»å‡»å†·å´
            if (currentTime - attacker.lastAttackTime < 300) {
                console.log('æ”»å‡»å†·å´ä¸­');
                return;
            }
            
            console.log(`${attacker === gameState.player ? 'ç©å®¶' : 'æ•Œäºº'}ä½¿ç”¨${weapon.name}è¿›è¡Œ${side === 'left' ? 'å·¦' : 'å³'}æ”»å‡»`);
            
            // æ¶ˆè€—èƒ½é‡
            attacker.energy -= weapon.energyCost;
            
            // åº”ç”¨æ”»å‡»åŠ¨ç”»
            const target = attacker === gameState.player ? gameState.enemy : gameState.player;
            const arm = side === 'left' ? 'leftArm' : 'rightArm';
            
            // åº”ç”¨æ”»å‡»åŠ›é‡åˆ°æ‰‹è‡‚ï¼ˆå¢åŠ åŠ›é‡ï¼‰
            const forceX = attacker.direction === 'right' ? 30 : -30;
            const forceY = -10;
            applyForceToRagdoll(attacker, arm, forceX, forceY);
            
            // æ£€æŸ¥æ˜¯å¦å‡»ä¸­ç›®æ ‡
            const hit = checkAttackHit(attacker, target, side, weapon.range);
            if (hit) {
                console.log('æ”»å‡»å‘½ä¸­ï¼');
                // é€ æˆä¼¤å®³
                target.health -= weapon.damage;
                
                // åº”ç”¨è¢«å‡»åŠ¨ç”»ï¼ˆå¢åŠ åŠ›é‡ï¼‰
                applyForceToRagdoll(target, 'torso', attacker.direction === 'right' ? 25 : -25, -15);
                
                // æ·»åŠ ä¼¤å®³æ•ˆæœ
                addDamageEffect(target.x, target.y, weapon.damage);
                
                // éœ‡åŠ¨å±å¹•
                shakeScreen();
            } else {
                console.log('æ”»å‡»æœªå‘½ä¸­');
            }
            
            // æ›´æ–°æ”»å‡»æ—¶é—´
            attacker.lastAttackTime = currentTime;
            
            // æ›´æ–°HUD
            updateHUD();
        }
        
        // æ£€æŸ¥æ”»å‡»æ˜¯å¦å‘½ä¸­
        function checkAttackHit(attacker, target, side, range) {
            const distance = Math.abs(attacker.x - target.x);
            const hitRange = range + attacker.width / 2 + target.width / 2;
            
            console.log(`æ”»å‡»æ£€æŸ¥: è·ç¦»=${distance.toFixed(1)}, æ”»å‡»èŒƒå›´=${hitRange.toFixed(1)}`);
            
            if (distance > hitRange) {
                return false;
            }
            
            // ç®€å•çš„æ–¹å‘æ£€æŸ¥
            if ((attacker.direction === 'right' && attacker.x > target.x) ||
                (attacker.direction === 'left' && attacker.x < target.x)) {
                console.log('æ–¹å‘é”™è¯¯ï¼Œæ”»å‡»æœªå‘½ä¸­');
                return false;
            }
            
            // æ£€æŸ¥æ‰‹è‡‚è§’åº¦æ˜¯å¦é€‚åˆæ”»å‡»
            const arm = side === 'left' ? 'leftArm' : 'rightArm';
            const armAngle = attacker.ragdoll[arm].angle;
            const angleThreshold = Math.PI / 3; // 60åº¦
            
            if (Math.abs(armAngle) > angleThreshold) {
                console.log('æ‰‹è‡‚è§’åº¦ä¸åˆé€‚ï¼Œæ”»å‡»æœªå‘½ä¸­');
                return false;
            }
            
            return true;
        }
        
        // æ·»åŠ ä¼¤å®³æ•ˆæœ
        function addDamageEffect(x, y, damage) {
            gameState.effects.push({
                type: 'damage',
                x: x + Math.random() * 40 - 20,
                y: y + Math.random() * 40 - 20,
                damage: damage,
                life: 30,
                maxLife: 30
            });
        }
        
        // éœ‡åŠ¨å±å¹•
        function shakeScreen() {
            canvas.style.transform = 'translateX(5px)';
            setTimeout(() => {
                canvas.style.transform = 'translateX(-5px)';
                setTimeout(() => {
                    canvas.style.transform = 'translateX(3px)';
                    setTimeout(() => {
                        canvas.style.transform = 'translateX(-3px)';
                        setTimeout(() => {
                            canvas.style.transform = 'translateX(0)';
                        }, 50);
                    }, 50);
                }, 50);
            }, 50);
        }
        
        // æ›´æ–°æ…¢åŠ¨ä½œUI
        function updateSlowMotionUI() {
            const indicator = document.getElementById('slowMotionIndicator');
            if (gameState.slowMotionActive) {
                indicator.classList.add('slow-motion-active');
            } else {
                indicator.classList.remove('slow-motion-active');
            }
        }
        
        // æ›´æ–°æ­¦å™¨UI
        function updateWeaponUI() {
            const weaponName = gameState.player.weapons[gameState.player.currentWeapon].name;
            document.getElementById('currentWeapon').textContent = weaponName;
        }
        
        // æ›´æ–°HUD
        function updateHUD() {
            document.getElementById('playerHealth').style.width = `${gameState.player.health}%`;
            document.getElementById('playerEnergy').style.width = `${gameState.player.energy}%`;
            document.getElementById('enemyHealth').style.width = `${gameState.enemy.health}%`;
        }
        
        // åˆå§‹åŒ–æ•°å­—é›¨
        function initDigitalRain() {
            const digitalRain = document.getElementById('digitalRain');
            digitalRain.innerHTML = '';
            
            for (let i = 0; i < 100; i++) {
                const pixel = document.createElement('div');
                pixel.className = 'pixel';
                pixel.style.left = `${Math.random() * 100}%`;
                pixel.style.animationDuration = `${Math.random() * 5 + 5}s`;
                pixel.style.animationDelay = `${Math.random() * 5}s`;
                digitalRain.appendChild(pixel);
            }
        }
        
        // æ›´æ–°ç©å®¶
        function updatePlayer() {
            const player = gameState.player;
            const speed = gameState.slowMotionActive ? player.speed * 0.5 : player.speed;
            
            // å¤„ç†ç§»åŠ¨
            if (gameState.keys.a) {
                player.x -= speed;
                player.direction = 'left';
                // æ·»åŠ ç§»åŠ¨åŠ¨ç”»æ•ˆæœ
                player.ragdoll.leftLeg.angularVelocity += 0.1;
                player.ragdoll.rightLeg.angularVelocity -= 0.1;
            }
            if (gameState.keys.d) {
                player.x += speed;
                player.direction = 'right';
                // æ·»åŠ ç§»åŠ¨åŠ¨ç”»æ•ˆæœ
                player.ragdoll.leftLeg.angularVelocity -= 0.1;
                player.ragdoll.rightLeg.angularVelocity += 0.1;
            }
            
            // å¤„ç†è·³è·ƒç‰©ç†
            if (!player.isGrounded) {
                player.y += 3; // å‡å°é‡åŠ›ï¼Œä½¿è·³è·ƒæ›´è‡ªç„¶
                
                // æ£€æŸ¥æ˜¯å¦ç€åœ°
                if (player.y >= 450) {
                    player.y = 450;
                    player.isGrounded = true;
                    console.log('ç©å®¶ç€åœ°');
                }
            }
            
            // æ¢å¤èƒ½é‡ï¼ˆå¢åŠ æ¢å¤é€Ÿåº¦ï¼‰
            if (player.energy < 100) {
                player.energy += 1;
                if (player.energy > 100) {
                    player.energy = 100;
                }
            }
            
            // è¾¹ç•Œæ£€æŸ¥
            const minX = player.width / 2;
            const maxX = canvas.width - player.width / 2;
            if (player.x < minX) {
                player.x = minX;
                // ç¢°æ’åå¼¹æ•ˆæœ
                player.ragdoll.torso.angularVelocity += 0.5;
            }
            if (player.x > maxX) {
                player.x = maxX;
                // ç¢°æ’åå¼¹æ•ˆæœ
                player.ragdoll.torso.angularVelocity -= 0.5;
            }
            
            // é™åˆ¶Yè½´ä½ç½®
            if (player.y > 500) {
                player.y = 500;
                player.isGrounded = true;
            }
        }
        
        // æ›´æ–°æ•Œäºº
        function updateEnemy() {
            const enemy = gameState.enemy;
            const player = gameState.player;
            const speed = gameState.slowMotionActive ? enemy.speed * 0.5 : enemy.speed;
            
            // ç®€å•çš„AIè¡Œä¸º
            if (Math.abs(enemy.x - player.x) > 120) {
                // é è¿‘ç©å®¶
                if (enemy.x < player.x) {
                    enemy.x += speed;
                    enemy.direction = 'right';
                    // æ·»åŠ ç§»åŠ¨åŠ¨ç”»æ•ˆæœ
                    enemy.ragdoll.leftLeg.angularVelocity -= 0.1;
                    enemy.ragdoll.rightLeg.angularVelocity += 0.1;
                } else {
                    enemy.x -= speed;
                    enemy.direction = 'left';
                    // æ·»åŠ ç§»åŠ¨åŠ¨ç”»æ•ˆæœ
                    enemy.ragdoll.leftLeg.angularVelocity += 0.1;
                    enemy.ragdoll.rightLeg.angularVelocity -= 0.1;
                }
            } else {
                // æ”»å‡»ç©å®¶
                const currentTime = Date.now();
                const attackInterval = 1000 / enemy.difficulty;
                
                if (currentTime - enemy.lastActionTime > attackInterval) {
                    // æœ‰30%æ¦‚ç‡è·³è·ƒ
                    if (Math.random() < 0.3 && enemy.isGrounded) {
                        enemy.y -= 50;
                        enemy.isGrounded = false;
                        console.log('æ•Œäººè·³è·ƒ');
                    } else {
                        const attackSide = Math.random() > 0.5 ? 'left' : 'right';
                        attack(enemy, attackSide);
                    }
                    enemy.lastActionTime = currentTime;
                }
            }
            
            // å¤„ç†è·³è·ƒç‰©ç†
            if (!enemy.isGrounded) {
                enemy.y += 3; // å‡å°é‡åŠ›ï¼Œä½¿è·³è·ƒæ›´è‡ªç„¶
                
                // æ£€æŸ¥æ˜¯å¦ç€åœ°
                if (enemy.y >= 450) {
                    enemy.y = 450;
                    enemy.isGrounded = true;
                    console.log('æ•Œäººç€åœ°');
                }
            }
            
            // è¾¹ç•Œæ£€æŸ¥
            const minX = enemy.width / 2;
            const maxX = canvas.width - enemy.width / 2;
            if (enemy.x < minX) {
                enemy.x = minX;
                // ç¢°æ’åå¼¹æ•ˆæœ
                enemy.ragdoll.torso.angularVelocity += 0.5;
            }
            if (enemy.x > maxX) {
                enemy.x = maxX;
                // ç¢°æ’åå¼¹æ•ˆæœ
                enemy.ragdoll.torso.angularVelocity -= 0.5;
            }
            
            // é™åˆ¶Yè½´ä½ç½®
            if (enemy.y > 500) {
                enemy.y = 500;
                enemy.isGrounded = true;
            }
        }
        
        // æ›´æ–°æ•ˆæœ
        function updateEffects() {
            for (let i = gameState.effects.length - 1; i >= 0; i--) {
                const effect = gameState.effects[i];
                effect.life--;
                
                if (effect.life <= 0) {
                    gameState.effects.splice(i, 1);
                }
            }
        }
        
        // æ£€æŸ¥æ¸¸æˆçŠ¶æ€
        function checkGameState() {
            // æ£€æŸ¥ç©å®¶æ˜¯å¦æ­»äº¡
            if (gameState.player.health <= 0) {
                gameState.player.health = 0;
                gameState.isGameRunning = false;
                gameState.currentScreen = 'gameOver';
                document.getElementById('defeatedBy').textContent = gameState.enemy.name;
                showScreen('gameOver');
                
                // é‡ç½®è¿›åº¦
                gameState.completedLevels = [];
                updateLevelSelection();
            }
            
            // æ£€æŸ¥æ•Œäººæ˜¯å¦æ­»äº¡
            if (gameState.enemy.health <= 0) {
                gameState.enemy.health = 0;
                gameState.isGameRunning = false;
                gameState.currentScreen = 'victory';
                document.getElementById('victoryEnemy').textContent = gameState.enemy.name;
                
                // æ·»åŠ åˆ°å·²å®Œæˆå…³å¡
                if (!gameState.completedLevels.includes(gameState.currentLevel)) {
                    gameState.completedLevels.push(gameState.currentLevel);
                }
                
                // æ›´æ–°ä¸‹ä¸€å…³ä¿¡æ¯
                if (gameState.currentLevel < gameState.maxLevel) {
                    document.getElementById('nextLevelNum').textContent = gameState.currentLevel + 1;
                    document.getElementById('nextLevelInfo').style.display = 'block';
                    document.getElementById('nextLevelBtn').style.display = 'inline-block';
                } else {
                    document.getElementById('nextLevelInfo').style.display = 'none';
                    document.getElementById('nextLevelBtn').style.display = 'none';
                }
                
                showScreen('victory');
                updateLevelSelection();
            }
        }
        
        // ç»˜åˆ¶æ¸¸æˆ
        function drawGame() {
            // ç»˜åˆ¶èƒŒæ™¯
            ctx.drawImage(gameState.stage.background, 0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶ç©å®¶
            drawRagdollCharacter(gameState.player, '#3B82F6');
            
            // ç»˜åˆ¶æ•Œäºº
            drawRagdollCharacter(gameState.enemy, '#EF4444');
            
            // ç»˜åˆ¶æ•ˆæœ
            drawEffects();
        }
        
        // ç»˜åˆ¶å¸ƒå¨ƒå¨ƒè§’è‰²
        function drawRagdollCharacter(character, color) {
            ctx.save();
            
            // è®¾ç½®è§’è‰²é¢œè‰²
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 3;
            
            // ç»˜åˆ¶èº«ä½“éƒ¨ä½
            const parts = ['torso', 'leftArm', 'rightArm', 'leftLeg', 'rightLeg', 'head'];
            
            for (const part of parts) {
                const partData = character.ragdoll[part];
                let partX = character.x + partData.x;
                let partY = character.y + partData.y;
                
                ctx.save();
                
                // ç»˜åˆ¶éƒ¨ä½
                if (part === 'head') {
                    // å¤´éƒ¨ï¼šåœ†å½¢
                    partX += Math.sin(character.ragdoll.torso.angle) * 30;
                    partY += Math.cos(character.ragdoll.torso.angle) * 30;
                    ctx.beginPath();
                    ctx.arc(partX, partY, partData.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç»˜åˆ¶æ‹–æ‹½æŒ‡ç¤ºå™¨
                    if (partData.isDragging) {
                        ctx.strokeStyle = '#FFFF00';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(partX, partY, partData.radius + 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                } else if (part === 'torso') {
                    // èº«ä½“ï¼šçŸ©å½¢
                    ctx.translate(partX, partY);
                    ctx.rotate(partData.angle);
                    ctx.strokeRect(-partData.width / 2, -partData.height / 2, partData.width, partData.height);
                    
                    // ç»˜åˆ¶æ‹–æ‹½æŒ‡ç¤ºå™¨
                    if (partData.isDragging) {
                        ctx.strokeStyle = '#FFFF00';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(-partData.width / 2 - 3, -partData.height / 2 - 3, partData.width + 6, partData.height + 6);
                    }
                } else if (part === 'leftArm' || part === 'rightArm' || part === 'leftLeg' || part === 'rightLeg') {
                    // å››è‚¢ï¼šçº¿æ®µ
                    const jointX = character.x + partData.joint.x;
                    const jointY = character.y + partData.joint.y;
                    
                    ctx.translate(jointX, jointY);
                    ctx.rotate(partData.angle);
                    
                    // ç»˜åˆ¶å…³èŠ‚ç‚¹
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç»˜åˆ¶è‚¢ä½“
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, partData.length);
                    ctx.stroke();
                    
                    // ç»˜åˆ¶æ‰‹éƒ¨/è„šéƒ¨
                    ctx.beginPath();
                    ctx.arc(0, partData.length, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç»˜åˆ¶æ‹–æ‹½æŒ‡ç¤ºå™¨
                    if (partData.isDragging) {
                        ctx.strokeStyle = '#FFFF00';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(-3, -3);
                        ctx.lineTo(3, 3);
                        ctx.moveTo(3, -3);
                        ctx.lineTo(-3, 3);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶æ•ˆæœ
        function drawEffects() {
            ctx.save();
            
            for (const effect of gameState.effects) {
                if (effect.type === 'damage') {
                    // ç»˜åˆ¶ä¼¤å®³æ•°å­—
                    const alpha = effect.life / effect.maxLife;
                    ctx.globalAlpha = alpha;
                    ctx.font = 'bold 24px Arial';
                    ctx.fillStyle = '#FF0000';
                    ctx.fillText(`-${effect.damage}`, effect.x, effect.y - (effect.maxLife - effect.life) * 0.5);
                }
            }
            
            ctx.restore();
        }
        
        // æ¸¸æˆä¸»å¾ªç¯
        function gameLoop() {
            try {
                if (gameState.isGameRunning) {
                    // æ›´æ–°æ…¢åŠ¨ä½œå†·å´
                    if (gameState.slowMotionCooldown > 0) {
                        gameState.slowMotionCooldown--;
                        if (gameState.slowMotionCooldown === 0 && gameState.slowMotionActive) {
                            gameState.slowMotionActive = false;
                            updateSlowMotionUI();
                        }
                    }
                    
                    // æ›´æ–°æ¸¸æˆçŠ¶æ€
                    updatePlayer();
                    updateEnemy();
                    updateEffects();
                    
                    // æ›´æ–°å¸ƒå¨ƒå¨ƒç‰©ç†
                    const dt = 1;
                    updateRagdollPhysics(gameState.player, dt);
                    updateRagdollPhysics(gameState.enemy, dt);
                    
                    // æ£€æŸ¥ç¢°æ’
                    checkCollisions();
                    
                    // æ£€æŸ¥æ¸¸æˆçŠ¶æ€
                    checkGameState();
                    
                    // ç»˜åˆ¶æ¸¸æˆ
                    drawGame();
                }
            } catch (error) {
                console.error('æ¸¸æˆå¾ªç¯é”™è¯¯:', error);
                console.error('é”™è¯¯å †æ ˆ:', error.stack);
                
                // å°è¯•æ¢å¤æ¸¸æˆ
                if (gameState.isGameRunning) {
                    console.log('å°è¯•æ¢å¤æ¸¸æˆ...');
                    // é‡ç½®å¯èƒ½å¯¼è‡´é”™è¯¯çš„çŠ¶æ€
                    gameState.player.isGrounded = true;
                    gameState.enemy.isGrounded = true;
                    if (gameState.player.y > 500) gameState.player.y = 450;
                    if (gameState.enemy.y > 500) gameState.enemy.y = 450;
                }
            }
            
            // ç»§ç»­æ¸¸æˆå¾ªç¯
            requestAnimationFrame(gameLoop);
        }
        
        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            gameState.isGameRunning = true;
            gameState.currentLevel = gameState.selectedLevel;
            loadLevel(gameState.currentLevel);
            showScreen('game');
        }
        
        // è¿›å…¥ä¸‹ä¸€å…³
        function nextLevel() {
            if (gameState.currentLevel < gameState.maxLevel) {
                gameState.currentLevel++;
                gameState.selectedLevel = gameState.currentLevel;
                startGame();
            } else {
                // æ¸¸æˆå®Œæˆ
                gameState.currentScreen = 'mainMenu';
                showScreen('mainMenu');
            }
        }
        
        // æ˜¾ç¤ºå±å¹•
        function showScreen(screenId) {
            // éšè—æ‰€æœ‰èœå•
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('levelSelect').classList.add('hidden');
            document.getElementById('controlsMenu').classList.add('hidden');
            document.getElementById('gameOver').classList.add('hidden');
            document.getElementById('victory').classList.add('hidden');
            
            // æ˜¾ç¤ºæŒ‡å®šèœå•
            if (screenId !== 'game') {
                document.getElementById(screenId).classList.remove('hidden');
            }
            
            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            gameState.currentScreen = screenId;
        }
        
        // æ›´æ–°å…³å¡é€‰æ‹©
        function updateLevelSelection() {
            const levelBtns = document.querySelectorAll('.difficulty-btn');
            
            levelBtns.forEach(btn => {
                const level = parseInt(btn.dataset.level);
                
                // æ£€æŸ¥å…³å¡æ˜¯å¦å·²å®Œæˆ
                if (gameState.completedLevels.includes(level)) {
                    btn.classList.remove('locked');
                    btn.classList.add('completed');
                    // ç§»é™¤é”å›¾æ ‡
                    const lockIcon = btn.querySelector('.lock-icon');
                    if (lockIcon) {
                        lockIcon.remove();
                    }
                } 
                // æ£€æŸ¥å…³å¡æ˜¯å¦å¯è§£é”ï¼ˆå‰ä¸€å…³å·²å®Œæˆï¼‰
                else if (level > 1 && gameState.completedLevels.includes(level - 1)) {
                    btn.classList.remove('locked');
                    // ç§»é™¤é”å›¾æ ‡
                    const lockIcon = btn.querySelector('.lock-icon');
                    if (lockIcon) {
                        lockIcon.remove();
                    }
                }
            });
        }
        
        // äº‹ä»¶ç›‘å¬å™¨
        document.getElementById('startGameBtn').addEventListener('click', () => {
            gameState.selectedLevel = 1;
            startGame();
        });
        
        document.getElementById('levelSelectBtn').addEventListener('click', () => {
            showScreen('levelSelect');
        });
        
        document.getElementById('controlsBtn').addEventListener('click', () => {
            showScreen('controlsMenu');
        });
        
        document.getElementById('closeControlsBtn').addEventListener('click', () => {
            showScreen('mainMenu');
        });
        
        document.getElementById('backToMenuBtn').addEventListener('click', () => {
            showScreen('mainMenu');
        });
        
        document.getElementById('restartGameBtn').addEventListener('click', () => {
            showScreen('mainMenu');
        });
        
        document.getElementById('nextLevelBtn').addEventListener('click', () => {
            nextLevel();
        });
        
        // å…³å¡é€‰æ‹©æŒ‰é’®
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const level = parseInt(btn.dataset.level);
                
                // æ£€æŸ¥å…³å¡æ˜¯å¦å¯è§£é”
                if (!btn.classList.contains('locked')) {
                    gameState.selectedLevel = level;
                    startGame();
                }
            });
        });
        
        // é”®ç›˜äº‹ä»¶
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        
        // é¼ æ ‡äº‹ä»¶
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);
        
        // è§¦æ‘¸äº‹ä»¶æ”¯æŒ
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            handleMouseDown(mouseEvent);
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            handleMouseMove(mouseEvent);
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleMouseUp(e);
        });
        
        // åˆå§‹åŒ–æ¸¸æˆ
        initGame();
        
        // å¼€å§‹æ¸¸æˆå¾ªç¯
        gameLoop();
    </script>
</body>
</html>
